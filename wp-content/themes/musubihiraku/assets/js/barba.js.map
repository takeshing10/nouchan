{"version":3,"file":"barba.js","sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../../node_modules/is-promise/index.js","../src/modules/Logger.ts","../../../node_modules/run-async/index.js","../src/hooks.ts","../../../node_modules/path-to-regexp/index.js","../src/schemas/attribute.ts","../src/utils/dom.ts","../src/utils/history.ts","../src/utils/helpers.ts","../src/utils/url.ts","../src/modules/Ignore.ts","../src/modules/Cache.ts","../src/utils/request.ts","../src/modules/Prevent.ts","../src/modules/Store.ts","../src/modules/Transitions.ts","../src/modules/Views.ts","../src/polyfills/index.ts","../src/schemas/page.ts","../src/core.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = (function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = (function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\treturn this;\n\t};\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","module.exports = isPromise;\n\nfunction isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n","/**\n * @barba/core/modules/Logger\n * <br><br>\n * ## Logger.\n *\n * - Display informations via the console\n *\n * @module core/modules/Logger\n * @preferred\n */\n\n/***/\n\n/**\n * Log levels, all lower level messages are printed\n *\n * 0. mute\n * 1. error = `console.error()`\n * 2. warning= `console.warn()`\n * 3. info = `console.info()`\n * 4. debug = `console.log()`\n */\nexport enum LogLevels {\n  off = 0,\n  error = 1,\n  warning = 2,\n  info = 3,\n  debug = 4,\n}\n\n/**\n * Global log level\n */\nlet _level: number = LogLevels.off;\n\nexport class Logger {\n  /**\n   * Get global log level.\n   */\n  public static getLevel(): number {\n    return _level;\n  }\n\n  /**\n   * Set global log level.\n   */\n  public static setLevel(name: keyof typeof LogLevels): number {\n    _level = LogLevels[name];\n\n    return _level;\n  }\n\n  /**\n   * Log \"prefix\".\n   */\n  private _source: string;\n\n  /**\n   * Creates an instance of Logger.\n   */\n  constructor(source: string) {\n    this._source = source;\n  }\n\n  /**\n   * Permanent, unremovable log.\n   */\n  // public print(...objects: any[]): void {\n  //   this._log(console.info, LogLevels.off, objects);\n  // }\n\n  /**\n   * Error log.\n   */\n  public error(...objects: any[]): void {\n    this._log(console.error, LogLevels.error, objects);\n  }\n\n  /**\n   * Warn log.\n   */\n  public warn(...objects: any[]): void {\n    this._log(console.warn, LogLevels.warning, objects);\n  }\n\n  /**\n   * Info log.\n   */\n  public info(...objects: any[]): void {\n    this._log(console.info, LogLevels.info, objects);\n  }\n\n  /**\n   * Debug log.\n   */\n  public debug(...objects: any[]): void {\n    this._log(console.log, LogLevels.debug, objects);\n  }\n\n  /**\n   * Internal logger.\n   */\n  private _log(fn: () => void, level: number, objects: any[]): void {\n    if (level <= Logger.getLevel()) {\n      fn.apply(console, ([`[${this._source}] `].concat(objects) as unknown) as [\n\n      ]);\n    }\n  }\n}\n","'use strict';\n\nvar isPromise = require('is-promise');\n\n/**\n * Return a function that will run a function asynchronously or synchronously\n *\n * example:\n * runAsync(wrappedFunction, callback)(...args);\n *\n * @param   {Function} func  Function to run\n * @param   {Function} cb    Callback function passed the `func` returned value\n * @return  {Function(arguments)} Arguments to pass to `func`. This function will in turn\n *                                return a Promise (Node >= 0.12) or call the callbacks.\n */\n\nvar runAsync = module.exports = function (func, cb) {\n  cb = cb || function () {};\n\n  return function () {\n    var async = false;\n    var args = arguments;\n\n    var promise = new Promise(function (resolve, reject) {\n      var answer = func.apply({\n        async: function () {\n          async = true;\n          return function (err, value) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(value);\n            }\n          };\n        }\n      }, Array.prototype.slice.call(args));\n\n      if (!async) {\n        if (isPromise(answer)) {\n          answer.then(resolve, reject);\n        } else {\n          resolve(answer);\n        }\n      }\n    });\n\n    promise.then(cb.bind(null, null), cb);\n\n    return promise;\n  }\n};\n\nrunAsync.cb = function (func, cb) {\n  return runAsync(function () {\n    var args = Array.prototype.slice.call(arguments);\n    if (args.length === func.length - 1) {\n      args.push(this.async());\n    }\n    return func.apply(this, args);\n  }, cb);\n};\n","/**\n * @barba/core/modules/hooks\n * <br><br>\n * ## Hooks manager.\n *\n * - Register and trigger hooks\n *\n * Hooks can be easily registered:\n *\n * ```js\n * hooks.leave(callback, context);\n * ```\n *\n * @module core/modules/hooks\n * @preferred\n */\n\n/***/\n\n// Third-party\nimport runAsync from 'run-async';\n// Definitions\nimport { HooksAll } from './defs';\n// Modules\nimport { Logger } from './modules/Logger';\n// Types\ninterface IHookData {\n  ctx: any;\n  fn: () => Promise<void>;\n}\n\nexport class Hooks {\n  /**\n   * Allow the use of `hooks[name](cb, ctx)`.\n   */\n  [key: string]: any;\n  // [key in HooksAll]?: any;\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All available hooks.\n   *\n   * See [[HooksAll]]\n   */\n  // TODO: get hooks from defs (DRY)?\n  public all: HooksAll[] = [\n    'ready',\n    'page',\n    'reset',\n    'currentAdded',\n    'currentRemoved',\n    'nextAdded',\n    'nextRemoved',\n    'beforeAppear',\n    'appear',\n    'afterAppear',\n    'appearCanceled',\n    'before',\n    'beforeLeave',\n    'leave',\n    'afterLeave',\n    'leaveCanceled',\n    'beforeEnter',\n    'enter',\n    'afterEnter',\n    'enterCanceled',\n    'after',\n  ];\n  /**\n   * Registered hooks.\n   *\n   * - Unique hook name\n   * - Associated data set(s) (callback + context)\n   */\n  public registered: Map<HooksAll, Set<IHookData>> = new Map();\n\n  constructor() {\n    this.init();\n  }\n\n  public init() {\n    this.registered.clear();\n    this.all.forEach(hook => {\n      if (!this[hook]) {\n        this[hook] = (fn: () => Promise<void>, ctx: any = null) => {\n          if (!this.registered.has(hook)) {\n            this.registered.set(hook, new Set());\n          }\n          const set = this.registered.get(hook);\n\n          set.add({\n            ctx,\n            fn,\n          });\n        };\n      }\n    });\n  }\n\n  /**\n   * Do hook.\n   *\n   * Trigger registered hooks.\n   */\n  public do(name: HooksAll, ...args: any): Promise<any> {\n    if (this.registered.has(name)) {\n      // Let's start a chain of promises\n      let chain = Promise.resolve();\n\n      this.registered.get(name).forEach(hook => {\n        // If needed, bind the right context\n        const fn = hook.ctx ? hook.fn.bind(hook.ctx) : hook.fn;\n        // Chain async hooks promisified\n        chain = chain.then(() => runAsync(fn)(...args));\n      });\n\n      return chain;\n    }\n\n    return Promise.resolve();\n  }\n\n  public clear(): void {\n    this.all.forEach(hook => {\n      delete this[hook];\n    });\n\n    this.init();\n  }\n\n  /**\n   * Help, print available and registered hooks.\n   */\n  public help(): void {\n    this.logger.info(`Available hooks: ${this.all.join(',')}`);\n    const registered: string[] = [];\n    this.registered.forEach((value, key) => registered.push(key));\n    this.logger.info(`Registered hooks: ${registered.join(',')}`);\n  }\n}\n\nconst hooks = new Hooks();\n\nexport { hooks };\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var whitelist = (options && options.whitelist) || undefined\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n      var c = path[k]\n      var matches = whitelist ? whitelist.indexOf(c) > -1 : true\n\n      if (matches) {\n        prev = c\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var pattern = capture || group\n    var delimiter = prev || defaultDelimiter\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: pattern\n        ? escapeGroup(pattern)\n        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) continue\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = options.delimiter || DEFAULT_DELIMITER\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (!token.prefix) {\n          route += '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + escapeString(delimiter) + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    var endToken = tokens[tokens.length - 1]\n    var isEndDelimited = typeof endToken === 'string'\n      ? endToken[endToken.length - 1] === delimiter\n      : endToken === undefined\n\n    if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","/**\n * @barba/core/schemas\n * <br><br>\n * ## Schemas description.\n *\n * @module core/schemas\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { ISchemaAttribute } from '../defs';\n\n/**\n * See [[ISchemaAttribute]]\n */\nexport const schemaAttribute: ISchemaAttribute = {\n  container: 'container',\n  namespace: 'namespace',\n  prefix: 'data-barba',\n  prevent: 'prevent',\n  wrapper: 'wrapper',\n};\n","/**\n * @barba/core/utils/dom\n * <br><br>\n * ## Dom utils\n *\n * - Access DOM contents\n * - DOM vs string conversions\n *\n * @module core/utils/dom\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { ISchemaAttribute, Link, Scope, Wrapper } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n\nexport class Dom {\n  private _attr: ISchemaAttribute = schemaAttribute;\n  private _parser: DOMParser = new DOMParser();\n  private _sibling: HTMLElement = null;\n\n  /**\n   * Convert HTMLDocument to string.\n   */\n  public toString(el: HTMLElement): string {\n    return el.outerHTML;\n  }\n\n  /**\n   * Parse HTML string to HTMLDocument.\n   */\n  // see https://github.com/barbajs/barba/issues/362\n  // Seems that using DOMParser.parseFromString causes this issue.\n  public toDocument(htmlString: string): HTMLDocument {\n    return this._parser.parseFromString(htmlString, 'text/html');\n  }\n\n  /**\n   * Parse HTML string to DIVElement.\n   *\n   * DOMParser.parseFromString fails with img[srcset] on iOS.\n   * see https://github.com/barbajs/barba/issues/362\n   */\n  public toElement(htmlString: string): HTMLDivElement {\n    const div = document.createElement('div');\n\n    div.innerHTML = htmlString;\n    return div;\n  }\n\n  /**\n   * Get HTML content.\n   */\n  public getHtml(doc: HTMLDocument = document): string {\n    return this.toString(doc.documentElement);\n  }\n\n  /**\n   * Get full document content.\n   */\n  // getDocument(el = document.documentElement) {\n  //   return this.toStr(el);\n  // },\n\n  /**\n   * Get `[data-barba=\"wrapper\"]`.\n   */\n  public getWrapper(scope: Scope = document): Wrapper {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.wrapper}\"]`\n    );\n  }\n\n  /**\n   * Get `[data-barba=\"container\"]`.\n   */\n  public getContainer(scope: Scope = document): HTMLElement | null {\n    return scope.querySelector(\n      `[${this._attr.prefix}=\"${this._attr.container}\"]`\n    );\n  }\n\n  /**\n   * Remove container and store next sibling (if applicable).\n   */\n  public removeContainer(container: HTMLElement) {\n    if (document.body.contains(container)) {\n      this._sibling = container.nextElementSibling as HTMLElement;\n      container.parentNode.removeChild(container);\n    }\n  }\n\n  /**\n   * Add container before next sibling or at the end of the wrapper.\n   */\n  public addContainer(container: HTMLElement, wrapper: HTMLElement) {\n    if (this._sibling) {\n      wrapper.insertBefore(container, this._sibling);\n    } else {\n      wrapper.appendChild(container);\n    }\n  }\n\n  /**\n   * Get `[data-barba-namespace]`.\n   */\n  public getNamespace(scope: Scope = document): string | null {\n    const ns = scope.querySelector(\n      `[${this._attr.prefix}-${this._attr.namespace}]`\n    );\n\n    return ns\n      ? ns.getAttribute(`${this._attr.prefix}-${this._attr.namespace}`)\n      : null;\n  }\n\n  /**\n   * Get URL from `href` value.\n   */\n  public getHref(el: Link): string | null {\n    // HTML tagName is UPPERCASE, xhtml tagName keeps existing case.\n    if (el.tagName && el.tagName.toLowerCase() === 'a') {\n      const href = el.getAttribute('href');\n\n      if (href) {\n        // When link comes from SVG, `href` returns an object, not a string.\n        return ((href as unknown) as SVGAnimatedString).baseVal || href;\n      }\n    }\n    return null;\n  }\n}\n\nconst dom = new Dom();\n\nexport { dom };\n","import { Trigger } from '../defs';\n\n/**\n * @barba/core/utils/history\n * <br><br>\n * ## History manager.\n *\n * - Keep track of the navigation history\n *\n * @module core/utils/history\n * @preferred\n */\n\n/***/\n\ninterface ICoords {\n  x: number;\n  y: number;\n}\n\n/**\n * History item.\n *\n * @property index\n * @property namespace\n * @property scroll\n * @property URL\n */\ninterface IHistoryItem {\n  /** index */\n  index: number;\n  /** namespace */\n  ns: string | undefined;\n  /** Scroll position */\n  scroll: ICoords;\n  /** URL */\n  url: string;\n}\n\nexport class History {\n  private _state: IHistoryItem[] = [];\n\n  /**\n   * Init with first state.\n   */\n  public init(url: string, ns: string): void {\n    const state: IHistoryItem = {\n      index: 0,\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    this._state.push(state);\n    window.history && window.history.replaceState(state, '', state.url);\n  }\n\n  /**\n   * Add a new state.\n   */\n  public add(\n    url: string,\n    ns: string,\n    i: number = null,\n    push: boolean = true\n  ): void {\n    const index = i || this.size;\n    const state: IHistoryItem = {\n      index,\n      ns,\n      scroll: {\n        x: window.scrollX,\n        y: window.scrollY,\n      },\n      url,\n    };\n\n    this._state.push(state);\n\n    if (push) {\n      window.history && window.history.pushState(state, '', state.url);\n    }\n  }\n\n  /**\n   * Remove last state.\n   */\n  public remove(): void {\n    this._state.pop();\n  }\n\n  /**\n   * Delete all states.\n   */\n  public clear(): void {\n    this._state = [];\n  }\n\n  /**\n   * Update current state.\n   */\n  public update(data: any): void {\n    const state: IHistoryItem = {\n      ...this.current,\n      ...data,\n    };\n\n    this.current = state;\n    window.history && window.history.replaceState(state, '', state.url);\n  }\n\n  /**\n   * Remove last state then go back.\n   */\n  public cancel(): void {\n    this.remove();\n\n    window.history && window.history.back();\n  }\n\n  /**\n   * Get state by index.\n   */\n  public get(index: number) {\n    return this._state[index];\n  }\n\n  public getDirection(index: number): Trigger {\n    let direction: Trigger = 'popstate';\n\n    if (index < this.current.index) {\n      direction = 'back';\n    } else if (index > this.current.index) {\n      direction = 'forward';\n    }\n\n    return direction;\n  }\n\n  /**\n   * Get/set the current state.\n   */\n  get current(): IHistoryItem {\n    return this._state[this._state.length - 1];\n  }\n\n  set current(state: IHistoryItem) {\n    this._state[this._state.length - 1] = state;\n  }\n\n  /**\n   * Get the previous state.\n   */\n  get previous(): IHistoryItem | null {\n    return this._state.length < 2 ? null : this._state[this._state.length - 2];\n  }\n\n  /**\n   * Get the state size.\n   */\n  get size(): number {\n    return this._state.length;\n  }\n}\n\nconst history = new History();\n\nexport { history };\n","/**\n * @barba/core/utils/helpers\n * <br><br>\n * ## Helpers\n *\n * - Update next page data\n *\n * @module core/utils/helpers\n * @preferred\n */\n\n/***/\n\n// Third-party\nimport ptr from 'path-to-regexp';\n// Definitions\nimport { ITransitionData } from '../defs';\nimport { ISchemaPage } from '../defs/schemas';\n// Utils\nimport { dom } from './dom';\nimport { history } from './history';\n\n/**\n * Update `data.next`, the title and the history\n */\nexport const update = async (\n  page: Promise<string | void>,\n  data: ITransitionData\n): Promise<void> => {\n  // If not already updated\n  if (!data.next.html) {\n    const html = await page;\n    const { next, trigger } = data;\n\n    if (html) {\n      // see: https://github.com/barbajs/barba/issues/362\n      // const nextDocument = dom.toDocument(html);\n      const nextDocument = dom.toElement(html);\n\n      next.namespace = dom.getNamespace(nextDocument);\n      next.container = dom.getContainer(nextDocument);\n      // see https://github.com/barbajs/barba/issues/362\n      // next.html = dom.getHtml(nextDocument);\n      // next.html = nextDocument.innerHTML;\n      next.html = html;\n\n      // Update history namespace (not available when initially set)\n      history.update({ ns: next.namespace });\n\n      // Update title.\n      const { title } = dom.toDocument(html);\n\n      document.title = title;\n    }\n  }\n};\n\n/**\n * Next tick\n */\nexport const nextTick = () =>\n  new Promise(resolve => {\n    window.requestAnimationFrame(resolve);\n    // DEV: same result?\n    // setTimeout(resolve, 0);\n  });\n\n/**\n * Turn a route string such as `/user/:name` into a regular expression.\n *\n * Used for:\n *\n * - routes to ignore\n * - route transition resolution\n *\n * @see https://www.npmjs.com/package/path-to-regexp\n */\nconst pathToRegexp = ptr;\n\nexport { pathToRegexp };\n","/**\n * @barba/core/utils/url\n * <br><br>\n * ## URL utils.\n *\n * - Collect and structure informations from URLs\n *\n * @module core/utils/url\n */\n\n/***/\n\n// Definitions\nimport { IGenericObject, IUrlBase } from '../defs';\n\n/**\n * Get location href.\n */\nexport const getHref = (): string => window.location.href;\n\n/**\n * Get location origin.\n */\nexport const getOrigin = (): string => window.location.origin;\n\n/**\n * Get port based on location.\n */\nexport const getPort = (p?: string) => {\n  const port = p || window.location.port;\n  const { protocol } = window.location;\n\n  if (port !== '') {\n    return parseInt(port, 10);\n  }\n\n  if (protocol === 'https:') {\n    return 443;\n  }\n\n  return 80;\n};\n\n/**\n * Get path from URL.\n */\nexport const getPath = (url: string): string => parse(url).path;\n\n/**\n * Get query object from URL.\n */\n// export const getQuery = (url: string): IGenericObject => parse(url).query;\n\n/**\n * Get hash from URL.\n */\n// export const getHash = (url: string): string => parse(url).hash;\n\n/**\n * Parse URL for path, query and hash.\n */\nexport const parse = (url: string): IUrlBase => {\n  // let path = clean(url);\n  let path = url.replace(getOrigin(), '');\n  let hash;\n  let query = {};\n\n  const hashIndex = path.indexOf('#');\n\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex + 1);\n    path = path.slice(0, hashIndex);\n  }\n\n  const queryIndex = path.indexOf('?');\n\n  if (queryIndex >= 0) {\n    query = parseQuery(path.slice(queryIndex + 1));\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    hash,\n    path,\n    query,\n  };\n};\n\n/**\n * Parse a query string to object.\n */\nexport const parseQuery = (str: string) =>\n  str.split('&').reduce((acc: IGenericObject, el: string) => {\n    const [key, value] = el.split('=');\n\n    acc[key] = value;\n\n    return acc;\n  }, {});\n\n/**\n * Clean URL, remove \"hash\" and/or \"trailing slash\".\n */\nexport const clean = (url: string) => url.replace(/(\\/#.*|\\/|#.*)$/, '');\n/**\n * Clean URL, remove \"origin\".\n */\n// export const clean = (url: string, origin = getOrigin()) =>\n//   url.replace(origin, '');\n","/**\n * @barba/core/modules/ignore\n * <br><br>\n * ## Manage ignore options.\n *\n * - cache\n * - prefetch\n *\n * @module core/modules/ignore\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption } from '../defs';\n// Utils\nimport { pathToRegexp } from '../utils/helpers';\nimport { parse } from '../utils/url';\n\nexport class Ignore {\n  private _ignoreAll: boolean;\n  private _ignoreRegexes: RegExp[] = [];\n\n  constructor(ignore: IgnoreOption) {\n    if (typeof ignore === 'boolean') {\n      this._ignoreAll = ignore;\n    } else {\n      const paths = Array.isArray(ignore) ? ignore : [ignore];\n\n      this._ignoreRegexes = paths.map(p => pathToRegexp(p));\n    }\n  }\n\n  public checkUrl(url: string): boolean {\n    if (typeof this._ignoreAll === 'boolean') {\n      return this._ignoreAll;\n    }\n\n    const { path } = parse(url);\n\n    return this._ignoreRegexes.some(regex => regex.exec(path) !== null);\n  }\n}\n","/**\n * @barba/core/modules/cache\n * <br><br>\n * ## Cache for storing URL / HTML.\n *\n * @module core/modules/cache\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { CacheAction, CacheRequest, ICacheData, IgnoreOption } from '../defs';\n// Modules\nimport { Ignore } from './Ignore';\n\nexport class Cache extends Ignore {\n  private _state: Map<string, ICacheData> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n  }\n\n  /**\n   * Set value to cache\n   */\n  public set(\n    href: string,\n    request: CacheRequest,\n    action: CacheAction\n  ): ICacheData {\n    if (!this.checkUrl(href)) {\n      this._state.set(href, {\n        action,\n        request,\n      });\n    }\n\n    return {\n      action,\n      request,\n    };\n  }\n\n  /**\n   * Get data from cache\n   */\n  public get(href: string): ICacheData {\n    return this._state.get(href);\n  }\n\n  /**\n   * Get request from cache\n   */\n  public getRequest(href: string): CacheRequest {\n    return this._state.get(href).request;\n  }\n\n  /**\n   * Get action from cache\n   */\n  public getAction(href: string): CacheAction {\n    return this._state.get(href).action;\n  }\n\n  /**\n   * Check if value exists into cache\n   */\n  public has(href: string): boolean {\n    return this._state.has(href);\n  }\n\n  /**\n   * Delete value from cache\n   */\n  public delete(href: string): boolean {\n    return this._state.delete(href);\n  }\n\n  /**\n   * Update cache value\n   */\n  public update(href: string, data: ICacheData): ICacheData {\n    const state = {\n      ...this._state.get(href),\n      ...data,\n    };\n    this._state.set(href, state);\n\n    return state;\n  }\n}\n","/**\n * @barba/core/utils/request\n * <br><br>\n * ## Fetch pages for transitions.\n *\n * - Includes timeout\n * - Uses Fetch API\n * - Handles errors\n *\n * @module core/utils/request\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { RequestError } from '../defs';\n\n/**\n * Init a page request.\n * Fetch the page and returns a promise with the text content.\n */\nfunction request(\n  url: string,\n  ttl: number = 2e3,\n  requestError: RequestError\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (xhr.status === 200) {\n          resolve(xhr.responseText);\n        } else if (xhr.status) {\n          // HTTP code is not 200, reject with response.\n          const res = {\n            status: xhr.status,\n            statusText: xhr.statusText,\n          };\n          requestError(url, res);\n          reject(res);\n        }\n      }\n    };\n    xhr.ontimeout = () => {\n      const err = new Error(`Timeout error [${ttl}]`);\n      requestError(url, err);\n      reject(err);\n    };\n    xhr.onerror = () => {\n      const err = new Error(`Fetch error`);\n      requestError(url, err);\n      reject(err);\n    };\n\n    xhr.open('GET', url);\n    xhr.timeout = ttl;\n    xhr.setRequestHeader(\n      'Accept',\n      'text/html,application/xhtml+xml,application/xml'\n    );\n    xhr.setRequestHeader('x-barba', 'yes');\n    xhr.send();\n  });\n}\n\nexport { request };\n","/**\n * @barba/core/modules/prevent\n * <br><br>\n * ## Prevent checks.\n *\n * - Gathers all the tests that allow Barba to work and play transitions\n *\n * @module core/modules/prevent\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { IgnoreOption, Link, PreventCheck } from '../defs';\n// Schemas\nimport { schemaAttribute } from '../schemas/attribute';\n// Utils\nimport { url } from '../utils';\n// Modules\nimport { Ignore } from './Ignore';\n\n/**\n * Make sure the browser supports `history.pushState`.\n */\nconst pushState: PreventCheck = () => !window.history.pushState;\n\n/**\n * Make sure there is an `el` and `href`.\n */\nconst exists: PreventCheck = ({ el, href }) => !el || !href;\n\n/**\n * If the user is pressing ctrl + click, the browser will open a new tab.\n */\nconst newTab: PreventCheck = ({ event }) =>\n  (event as KeyboardEvent).which > 1 ||\n  (event as KeyboardEvent).metaKey ||\n  (event as KeyboardEvent).ctrlKey ||\n  (event as KeyboardEvent).shiftKey ||\n  (event as KeyboardEvent).altKey;\n\n/**\n * If the link has `_blank` target.\n */\nconst blank: PreventCheck = ({ el }) =>\n  el.hasAttribute('target') && (el as Link).target === '_blank';\n\n/**\n * If the domain is the same (in order to avoid pushState cross origin security problem).\n * Note: SVGAElement do not have `protocol` neither `hostname` properties.\n */\nconst corsDomain: PreventCheck = ({ el }) =>\n  ((el as HTMLAnchorElement).protocol !== undefined &&\n    window.location.protocol !== (el as HTMLAnchorElement).protocol) ||\n  ((el as HTMLAnchorElement).hostname !== undefined &&\n    window.location.hostname !== (el as HTMLAnchorElement).hostname);\n\n/**\n * If the port is the same.\n * Note: SVGAElement do not have `port` property.\n */\nconst corsPort: PreventCheck = ({ el }) =>\n  (el as HTMLAnchorElement).port !== undefined &&\n  url.getPort() !== url.getPort((el as HTMLAnchorElement).port);\n\n/**\n * If the link has download attribute.\n */\nconst download: PreventCheck = ({ el }) =>\n  el.getAttribute && typeof el.getAttribute('download') === 'string';\n\n/**\n * If the links contains [data-barba-prevent] or [data-barba-prevent=\"self\"].\n */\nconst preventSelf: PreventCheck = ({ el }) =>\n  el.hasAttribute(`${schemaAttribute.prefix}-${schemaAttribute.prevent}`);\n\n/**\n * If some link ancestor contains [data-barba-prevent=\"all\"].\n */\nconst preventAll: PreventCheck = ({ el }) =>\n  Boolean(\n    el.closest(`[${schemaAttribute.prefix}-${schemaAttribute.prevent}=\"all\"]`)\n  );\n\n/**\n * If the link is the current URL.\n *\n * > Not in the test suite.\n */\nconst sameUrl: PreventCheck = ({ href }) =>\n  url.clean(href) === url.clean(window.location.href);\n\nexport class Prevent extends Ignore {\n  public suite: string[] = [];\n  public tests: Map<string, PreventCheck> = new Map();\n\n  constructor(ignore: IgnoreOption) {\n    super(ignore);\n    this.init();\n  }\n\n  public init(): void {\n    // Add defaults\n    this.add('pushState', pushState);\n    this.add('exists', exists);\n    this.add('newTab', newTab);\n    this.add('blank', blank);\n    this.add('corsDomain', corsDomain);\n    this.add('corsPort', corsPort);\n    this.add('download', download);\n    this.add('preventSelf', preventSelf);\n    this.add('preventAll', preventAll);\n\n    // Outside of the test suite\n    this.add('sameUrl', sameUrl, false);\n  }\n\n  public add(name: string, check: PreventCheck, suite: boolean = true): void {\n    this.tests.set(name, check);\n    suite && this.suite.push(name);\n  }\n\n  /**\n   * Run individual test\n   */\n  public run(name: string, el: Link, event: Event, href: string): boolean {\n    return this.tests.get(name)({\n      el,\n      event,\n      href,\n    });\n  }\n\n  /**\n   * Run test suite\n   */\n  public checkLink(el: Link, event: Event, href: string): boolean {\n    return this.suite.some(name => this.run(name, el, event, href));\n  }\n}\n","/**\n * @barba/core/modules/store\n * <br><br>\n * ## Transitions store.\n *\n * - Resolve transition\n * - Manage rules\n *\n * @module core/modules/store\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport {\n  IRule,\n  IRules,\n  ITransitionAppear,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionPage,\n  RuleName,\n} from '../defs';\n\n// Modules\nimport { Logger } from './Logger';\n\nexport class Store {\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * All registered transitions.\n   */\n  public all: ITransitionPage[] = [];\n  /**\n   * \"Appear only\" registered transitions.\n   */\n  public appear: ITransitionAppear[] = [];\n  /**\n   * Rules for transition resolution.\n   *\n   * Defaults:\n   *\n   * - namespace\n   * - custom\n   */\n  private _rules: IRule[] = [\n    {\n      name: 'namespace',\n      type: 'strings',\n    },\n    {\n      name: 'custom',\n      type: 'function',\n    },\n  ];\n\n  /**\n   * Init store.\n   */\n  constructor(transitions: ITransitionPage[] = []) {\n    if (transitions) {\n      // TODO: add check for valid transitions? criteria? (appear || enter && leave)\n      this.all = this.all.concat(transitions);\n    }\n    this.update();\n  }\n\n  /**\n   * Add rule or transition.\n   */\n  public add(type: 'rule' | 'transition', data: any): void {\n    switch (type) {\n      case 'rule':\n        // TODO: check for valid rule\n        this._rules.splice(data.position || 0, 0, data.value);\n        break;\n      case 'transition':\n      default:\n        // TODO: check for valid transition\n        this.all.push(data);\n        break;\n    }\n\n    this.update();\n  }\n\n  /**\n   * Resolve transition.\n   */\n  public resolve(\n    data: ITransitionData,\n    filters: ITransitionFilters = {}\n  ): ITransitionAppear | ITransitionPage {\n    // Filter on \"appear\"\n    let transitions = filters.appear ? this.appear : this.all;\n\n    // Filter on \"self\"\n    if (filters.self) {\n      transitions = transitions.filter(t => t.name && t.name === 'self');\n    } else {\n      transitions = transitions.filter(t => !t.name || t.name !== 'self');\n    }\n\n    // All matching transition infos\n    const matching = new Map();\n\n    // Active = first of valid transitions\n    // sorted by directions (from/to, from || to, …)\n    const active = transitions.find(t => {\n      let valid = true;\n      const match = {};\n\n      if (filters.self && t.name === 'self') {\n        return true;\n      }\n\n      // Check rules\n      this._rules.reverse().forEach(rule => {\n        if (valid) {\n          valid = this._check(t, rule, data, match);\n          // From/to check, only for page transitions\n          if (!filters.appear) {\n            if (t.from && t.to) {\n              valid =\n                this._check(t, rule, data, match, 'from') &&\n                this._check(t, rule, data, match, 'to');\n            }\n            if (t.from && !t.to) {\n              valid = this._check(t, rule, data, match, 'from');\n            }\n            if (!t.from && t.to) {\n              valid = this._check(t, rule, data, match, 'to');\n            }\n          }\n        }\n      });\n\n      matching.set(t, match);\n\n      return valid;\n    });\n\n    const activeMatch = matching.get(active);\n    const transitionType = [];\n    if (filters.appear) {\n      transitionType.push('appear');\n    } else {\n      transitionType.push('page');\n    }\n    if (filters.self) {\n      transitionType.push('self');\n    }\n\n    if (activeMatch) {\n      // Log resolved transition\n      const infos: any[] = [active];\n      // Log if matching criteria\n      Object.keys(activeMatch).length > 0 && infos.push(activeMatch);\n\n      this.logger.info(\n        `Transition found [${transitionType.join(',')}]`,\n        ...infos\n      );\n    } else {\n      this.logger.info(`No transition found [${transitionType.join(',')}]`);\n    }\n\n    return active;\n  }\n\n  /**\n   * ### Update store.\n   *\n   * - Reorder transition by priorities\n   * - Get wait indicator\n   * - Get appear transitions\n   */\n  public update(): void {\n    // Reorder by priorities\n    this.all = this.all\n      .map(t => this._addPriority(t))\n      .sort((a, b) => a.priority - b.priority)\n      .reverse()\n      .map(t => {\n        delete t.priority;\n\n        return t;\n      });\n    this.appear = this.all.filter(\n      t => t.appear !== undefined\n    ) as ITransitionAppear[];\n  }\n\n  /**\n   * ### Check if transition apply.\n   *\n   * Based on rule, page data and optional direction:\n   *\n   * 1. transition has no rule \"property\":\n   *    - always returns true\n   * 2. transition has rule \"property\":\n   *     - \"strings\" should be present on both side (transition + page) and match\n   *     - \"function\" should return true\n   */\n  private _check(\n    transition: ITransitionPage,\n    rule: IRule,\n    data: ITransitionData,\n    match: any,\n    direction?: 'from' | 'to'\n  ): boolean {\n    let isValid = true;\n    let hasMatch = false;\n    const t = transition;\n    const { name, type } = rule;\n    const strRule = name as IRules['strings'];\n    const objRule = name as IRules['object'];\n    const fnName = name as IRules['function'];\n    const base = direction ? t[direction] : t; // = t || t.from || t.to\n    const page = direction === 'to' ? data.next : data.current; // = current || next\n    const exist = direction ? base && base[name] : base[name];\n\n    // If transition rule exists\n    if (exist) {\n      switch (type) {\n        case 'strings':\n        default: {\n          // Array support\n          const names: string[] = Array.isArray(base[strRule])\n            ? (base[strRule] as string[])\n            : [base[strRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[strRule] && names.indexOf(page[strRule]) !== -1) {\n            hasMatch = true;\n          }\n          // If transition prop is different from current, not valid\n          if (names.indexOf(page[strRule]) === -1) {\n            isValid = false;\n          }\n          break;\n        }\n\n        case 'object': {\n          // Array support\n          const names: string[] = Array.isArray(base[objRule])\n            ? (base[objRule] as string[])\n            : [base[objRule] as string];\n\n          // For matching, prop should be present on both sides and match\n          if (page[objRule]) {\n            if (\n              page[objRule].name &&\n              names.indexOf(page[objRule].name) !== -1\n            ) {\n              hasMatch = true;\n            }\n            // If transition prop is different from current, not valid\n            if (names.indexOf(page[objRule].name) === -1) {\n              isValid = false;\n            }\n          }\n          break;\n        }\n\n        case 'function':\n          if (base[fnName](data)) {\n            hasMatch = true;\n          } else {\n            isValid = false;\n          }\n          break;\n      }\n\n      if (hasMatch) {\n        if (direction) {\n          match[direction] = match[direction] || {};\n          match[direction][name] = t[direction][name];\n        } else {\n          match[name] = t[name];\n        }\n      }\n    }\n\n    return isValid;\n  }\n\n  /**\n   * ### Calculate transition priority.\n   *\n   * Based on:\n   *\n   * - rule \"position\" (index) give tens, hundreds, thousands, …\n   * - from/to properties give units (0, 1 or 2)\n   */\n  private _calculatePriority(\n    t: ITransitionPage,\n    ruleName: RuleName,\n    ruleIndex: number\n  ): number {\n    let priority = 0;\n\n    if (\n      t[ruleName] ||\n      (t.from && t.from[ruleName]) ||\n      (t.to && t.to[ruleName])\n    ) {\n      priority += Math.pow(10, ruleIndex);\n\n      if (t.from && t.from[ruleName]) {\n        priority += 1;\n      }\n      if (t.to && t.to[ruleName]) {\n        priority += 2;\n      }\n    }\n\n    return priority;\n  }\n\n  private _addPriority(t: ITransitionPage): ITransitionPage {\n    t.priority = 0;\n    let priority = 0;\n\n    this._rules.forEach((rule, i) => {\n      const { name } = rule;\n      const index = i + 1;\n\n      priority += this._calculatePriority(t, name, index);\n    });\n\n    t.priority = priority;\n\n    return t;\n  }\n}\n","/**\n * @barba/core/modules/transitions\n * <br><br>\n * ## Transitions manager.\n *\n * - Handle hooks and transition lifecycle\n *\n * @module core/modules/transitions\n * @preferred\n */\n\n/***/\n\n// Third-party\nimport runAsync from 'run-async';\n// Definitions\nimport {\n  HooksTransition,\n  HooksTransitionMap,\n  ITransitionAppear,\n  ITransitionData,\n  ITransitionFilters,\n  ITransitionPage,\n  Wrapper,\n} from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Utils\nimport { dom, helpers } from '../utils';\n// Modules\nimport { Logger } from './Logger';\nimport { Store } from './Store';\n\nexport class Transitions {\n  public logger: Logger = new Logger('@barba/core');\n  public store: Store;\n  private _running: boolean = false;\n\n  constructor(transitions: ITransitionPage[] = []) {\n    this.store = new Store(transitions);\n  }\n\n  /**\n   * Get resolved transition\n   *\n   * - based on data\n   */\n  public get(\n    data: ITransitionData,\n    filters?: ITransitionFilters\n  ): ITransitionAppear | ITransitionPage {\n    return this.store.resolve(data, filters);\n  }\n\n  /**\n   * Animation running status.\n   */\n  get isRunning(): boolean {\n    return this._running;\n  }\n  set isRunning(status: boolean) {\n    this._running = status;\n  }\n\n  /**\n   * Check for registered appear transition(s).\n   */\n  get hasAppear(): boolean {\n    return this.store.appear.length > 0;\n  }\n\n  /**\n   * Check for registered self transition.\n   */\n  get hasSelf(): boolean {\n    return this.store.all.some(t => t.name === 'self');\n  }\n\n  /**\n   * ### Wait indicator.\n   *\n   * Tells Barba to get next page data<br>\n   * before starting the resolution<br>\n   * because some registered transitions need<br>\n   * next page data to be resolved (eg: `sync: true`, `to: { namespace }`, …)\n   */\n  get shouldWait(): boolean {\n    return this.store.all.some(t => (t.to && !t.to.route) || t.sync);\n  }\n\n  /**\n   * ### Do \"appear\" transition.\n   *\n   * Hooks: see [[HooksAppear]].\n   */\n  public async doAppear({\n    data,\n    transition,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionAppear;\n  }) {\n    const t = transition || {};\n    this._running = true;\n\n    try {\n      await this._doAsyncHook('beforeAppear', data, t);\n      await this.appear(data, t);\n      await this._doAsyncHook('afterAppear', data, t);\n    } catch (error) {\n      this._running = false;\n      this.logger.error(error);\n      // TODO: use this hooks on `cancel()`\n      // await this._doAsyncHook('appearCanceled', data, t);\n      // TODO: should I throw or should I log…\n      throw new Error('Transition error [appear]');\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * ### Do \"page\" transition.\n   *\n   * Hooks: see [[HooksPage]].\n   *\n   * `sync: false` (default) order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. leave\n   * 4. afterLeave\n   * 5. beforeEnter\n   * 6. enter\n   * 7. afterEnter\n   * 8. after\n   *\n   * `sync: true` order:\n   *\n   * 1. before\n   * 2. beforeLeave\n   * 3. beforeEnter\n   * 4. leave & enter\n   * 5. afterLeave\n   * 6. afterEnter\n   * 7. after\n   */\n  public async doPage({\n    data,\n    transition,\n    page,\n    wrapper,\n  }: {\n    data: ITransitionData;\n    transition: ITransitionPage;\n    page: Promise<string | void>;\n    wrapper: Wrapper;\n  }) {\n    const t = transition || {};\n    const sync = t.sync === true || false;\n\n    this._running = true;\n\n    try {\n      // Check sync mode, wait for next content\n      if (sync) {\n        await helpers.update(page, data);\n      }\n\n      await this._doAsyncHook('before', data, t);\n\n      if (sync) {\n        try {\n          await this.add(data, wrapper);\n          // Before actions\n          await this._doAsyncHook('beforeLeave', data, t);\n          await this._doAsyncHook('beforeEnter', data, t);\n\n          // Actions\n          await Promise.all([this.leave(data, t), this.enter(data, t)]);\n\n          // After actions\n          await this._doAsyncHook('afterLeave', data, t);\n          await this._doAsyncHook('afterEnter', data, t);\n        } catch (error) {\n          // TODO: use these hooks on `cancel()`\n          // await this._doAsyncHook('leaveCanceled', data, t);\n          // await this._doAsyncHook('enterCanceled', data, t);\n          throw new Error('Transition error [page][sync]');\n        }\n      } else {\n        let leaveResult: any = false;\n        try {\n          // Leave\n          await this._doAsyncHook('beforeLeave', data, t);\n\n          leaveResult = await Promise.all([\n            this.leave(data, t),\n            helpers.update(page, data),\n          ]).then(values => values[0]);\n\n          await this._doAsyncHook('afterLeave', data, t);\n\n          // TODO: check here \"valid\" page result\n          // before going further\n        } catch (error) {\n          // TODO: use this hooks on `cancel()`\n          // await this._doAsyncHook('leaveCanceled', data, t);\n          throw new Error('Transition error [page][leave]');\n        }\n\n        try {\n          // Enter\n          /* istanbul ignore else */\n          if (leaveResult !== false) {\n            await this.add(data, wrapper);\n\n            await this._doAsyncHook('beforeEnter', data, t);\n            await this.enter(data, t, leaveResult);\n            await this._doAsyncHook('afterEnter', data, t);\n          }\n        } catch (error) {\n          // TODO: use these hooks on `cancel()`\n          // await this._doAsyncHook('leaveCanceled', data, t);\n          // await this._doAsyncHook('enterCanceled', data, t);\n          throw new Error('Transition error [page][enter]');\n        }\n      }\n\n      await this._doAsyncHook('after', data, t);\n\n      // Remove current contaienr\n      await this.remove(data);\n    } catch (error) {\n      this._running = false;\n      // TODO: use cases for cancellation\n      this.logger.error(error);\n\n      // TODO: should I throw or should I log…\n      throw new Error('Transition error');\n    }\n\n    this._running = false;\n  }\n\n  /**\n   * Appear hook + async \"appear\" transition.\n   */\n  public async appear(\n    data: ITransitionData,\n    t: ITransitionAppear\n  ): Promise<void> {\n    await hooks.do('appear', data, t);\n\n    return t.appear ? runAsync(t.appear)(data) : Promise.resolve();\n  }\n\n  /**\n   * Leave hook + async \"leave\" transition.\n   */\n  public async leave(data: ITransitionData, t: ITransitionPage): Promise<any> {\n    await hooks.do('leave', data, t);\n\n    return t.leave ? runAsync(t.leave)(data) : Promise.resolve();\n  }\n\n  /**\n   * Enter hook + async \"enter\" transition.\n   */\n  public async enter(\n    data: ITransitionData,\n    t: ITransitionPage,\n    leaveResult?: any\n  ): Promise<void> {\n    await hooks.do('enter', data, t);\n\n    return t.enter ? runAsync(t.enter)(data, leaveResult) : Promise.resolve();\n  }\n\n  /**\n   * Add next container.\n   */\n  public async add(data: ITransitionData, wrapper: Wrapper): Promise<void> {\n    dom.addContainer(data.next.container, wrapper);\n    hooks.do('nextAdded', data);\n  }\n\n  /**\n   * Remove current container.\n   */\n  public async remove(data: ITransitionData): Promise<void> {\n    dom.removeContainer(data.current.container);\n    hooks.do('currentRemoved', data);\n  }\n\n  /**\n   * Do hooks + async transition methods.\n   */\n  private async _doAsyncHook(\n    hook: HooksTransition,\n    data: ITransitionData,\n    t: HooksTransitionMap\n  ): Promise<void> {\n    await hooks.do(hook, data, t);\n\n    return t[hook] ? runAsync(t[hook])(data) : Promise.resolve();\n  }\n}\n","/**\n * @barba/core/modules/views\n * <br><br>\n * ## Views manager.\n *\n * @module core/modules/views\n * @preferred\n */\n\n/***/\n\n// Definitions\nimport { HooksView, IHookViewData, IView } from '../defs';\n// Hooks\nimport { hooks } from '../hooks';\n// Types\ntype Hook = (data: IHookViewData) => void;\n\nexport class Views {\n  /**\n   * Available hook names for views.\n   */\n  public names: HooksView[] = [\n    'beforeAppear',\n    'afterAppear',\n    'beforeLeave',\n    'afterLeave',\n    'beforeEnter',\n    'afterEnter',\n  ];\n  /**\n   * Registered views by namespace.\n   */\n  public byNamespace: Map<string, IView> = new Map();\n\n  /**\n   * Init views.\n   */\n  constructor(views: IView[]) {\n    if (views.length === 0) {\n      return;\n    }\n\n    // TODO: add check\n    // for valid views? criteria? (namespace property, string ?)\n    // or duplicate\n    views.forEach(view => {\n      this.byNamespace.set(view.namespace, view);\n    });\n\n    this.names.forEach(name => {\n      hooks[name](this._createHook(name), this);\n    });\n  }\n\n  /**\n   * Create the hook method.\n   *\n   * - get view based on namespace\n   * - execute callback with transition data\n   */\n  private _createHook(name: HooksView): Hook {\n    return data => {\n      const { namespace } = name.match(/enter/i) ? data.next : data.current;\n      const view = this.byNamespace.get(namespace);\n\n      // TODO: manage self…\n      // if (view && data.trigger !== 'self') {\n      if (view) {\n        view[name] && view[name](data);\n      }\n    };\n  }\n}\n","// Element.prototype.matches polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    (Element as any).prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n}\n\n// Element.prototype.closest polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function closest(s: string) {\n    let el = this;\n\n    do {\n      if (el.matches(s)) {\n        return el;\n      }\n\n      el = (el.parentElement || el.parentNode) as Element;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}\n","/**\n * @module core/schemas\n */\n\n// Definitions\nimport { ISchemaPage } from '../defs';\n\n/**\n * See [[ISchemaPage]]\n */\nexport const schemaPage: ISchemaPage = {\n  container: undefined,\n  html: undefined,\n  namespace: undefined,\n  url: {\n    hash: undefined,\n    href: undefined,\n    path: undefined,\n    query: {},\n  },\n};\n","/**\n * @barba/core\n * <br><br>\n * ## Barba core object\n *\n * Main methods:\n *\n * - `.init()` for initialization with options\n * - `.use()` for plugins\n *\n * @module core\n */\n\n/***/\n\nimport { version } from '../package.json';\n// Definitions\nimport {\n  IBarbaOptions,\n  IBarbaPlugin,\n  IgnoreOption,\n  ISchemaPage,\n  ITransitionAppear,\n  ITransitionData,\n  ITransitionPage,\n  Link,\n  LinkEvent,\n  RequestCustomError,\n  RequestErrorOrResponse,\n  SchemaAttributeValues,\n  Trigger,\n  Wrapper,\n} from './defs';\n// Hooks\nimport { hooks } from './hooks';\n// Modules\nimport { Cache } from './modules/Cache';\nimport { Logger } from './modules/Logger';\nimport { Prevent } from './modules/Prevent';\nimport { Transitions } from './modules/Transitions';\nimport { Views } from './modules/Views';\n// Polyfills\nimport './polyfills';\n// Schemas\nimport { schemaAttribute } from './schemas/attribute';\nimport { schemaPage } from './schemas/page';\n// Utils\nimport { dom, helpers, history, request, url } from './utils';\n\nexport class Core {\n  /**\n   * Version.\n   */\n  public version: string = version;\n  /**\n   * Schemas.\n   */\n  public schemaPage: ISchemaPage = schemaPage;\n  /**\n   * Logger class, allows plugins to create Logger.\n   */\n  public Logger: typeof Logger = Logger;\n  /**\n   * Barba logger.\n   */\n  public logger: Logger = new Logger('@barba/core');\n  /**\n   * Plugins.\n   */\n  public plugins: Array<IBarbaPlugin<any>> = [];\n  /**\n   * Options\n   */\n  public timeout: number;\n  public cacheIgnore: IgnoreOption;\n  public prefetchIgnore: IgnoreOption;\n  /**\n   * Hooks\n   */\n  public hooks = hooks;\n  /**\n   * Modules.\n   */\n  // public history: History;\n  public cache: Cache;\n  public prevent: Prevent;\n  public transitions: Transitions;\n  public views: Views;\n  /**\n   * Utils.\n   */\n  public dom = dom;\n  public helpers = helpers;\n  public history = history;\n  public request = request;\n  public url = url;\n\n  private _data: ITransitionData;\n  private _requestCustomError: RequestCustomError;\n  private _wrapper: Wrapper;\n\n  /**\n   * ### Init plugin with options.\n   *\n   * See [[IBarbaPlugin]] for more details.\n   */\n  public use<T>(plugin: IBarbaPlugin<T>, options?: T): void {\n    const installedPlugins = this.plugins;\n\n    // Plugin installation\n    if (installedPlugins.indexOf(plugin) > -1) {\n      this.logger.warn(`Plugin [${plugin.name}] already installed.`);\n\n      return;\n    }\n\n    if (typeof plugin.install !== 'function') {\n      this.logger.warn(`Plugin [${plugin.name}] has no \"install\" method.`);\n\n      return;\n    }\n\n    plugin.install(this, options);\n    installedPlugins.push(plugin);\n  }\n\n  /**\n   * ### Init barba with options.\n   *\n   * See [[IBarbaOptions]] for more details.\n   *\n   * Default values are:\n   *\n   * - transitions: `[]`\n   * - views: `[]`\n   * - timeout: `2e3`\n   * - cacheIgnore: `false`\n   * - prefetchIgnore: `false`\n   * - schema: [[SchemaAttribute]]\n   * - debug: `false`\n   * - logLevel: `'debug'`\n   */\n  public init(\n    /** @ignore */ {\n      transitions = [],\n      views = [],\n      prevent: preventCustom = null,\n      timeout = 2e3,\n      requestError,\n      cacheIgnore = false,\n      prefetchIgnore = false,\n      schema = schemaAttribute,\n      debug = false,\n      logLevel = 'off',\n    }: IBarbaOptions = {}\n  ) {\n    // 0. Set logger level and print version\n    Logger.setLevel(debug === true ? 'debug' : logLevel);\n    this.logger.info(this.version);\n\n    // 1. Manage options\n    Object.keys(schema).forEach(k => {\n      const attr = k as SchemaAttributeValues;\n\n      if (schemaAttribute[attr]) {\n        schemaAttribute[attr] = schema[attr];\n      }\n    });\n    this._requestCustomError = requestError;\n    this.timeout = timeout;\n    this.cacheIgnore = cacheIgnore;\n    this.prefetchIgnore = prefetchIgnore;\n\n    // 2. Get and check wrapper\n    this._wrapper = this.dom.getWrapper();\n    if (!this._wrapper) {\n      throw new Error('[@barba/core] No Barba wrapper found');\n    }\n    this._wrapper.setAttribute('aria-live', 'polite'); // A11y\n\n    // 3. Init pages (get \"current\" data)\n    this._resetData();\n\n    const { current } = this.data;\n\n    if (!current.container) {\n      throw new Error('[@barba/core] No Barba container found');\n    }\n\n    // 4. Init other modules\n    this.cache = new Cache(cacheIgnore);\n    this.prevent = new Prevent(prefetchIgnore);\n    this.transitions = new Transitions(transitions);\n    this.views = new Views(views);\n\n    // Add prevent custom\n    if (preventCustom !== null) {\n      if (typeof preventCustom !== 'function') {\n        throw new Error('[@barba/core] Prevent should be a function');\n      }\n\n      this.prevent.add('preventCustom', preventCustom);\n    }\n\n    // 5. Use \"current\" data\n    // Init history\n    this.history.init(current.url.href, current.namespace);\n    // Add to cache\n    // TODO: do not cache renderer HTML, only request results…\n    // this.cache.set(current.url.href, Promise.resolve(current.html), 'init');\n\n    // 6. Bind context\n    this._onLinkEnter = this._onLinkEnter.bind(this);\n    this._onLinkClick = this._onLinkClick.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._bind();\n\n    // 7. Init plugins\n    this.plugins.forEach(plugin => plugin.init());\n\n    // 8. Barba ready\n    // Set next + trigger for appear and `beforeEnter`/`afterEnter` view on page load.\n    const readyData = this.data;\n\n    readyData.trigger = 'barba';\n    readyData.next = readyData.current;\n    this.hooks.do('ready', readyData);\n\n    // 9. Finally, do appear…\n    this.appear(readyData);\n    // Clean data for first barba transition…\n    this._resetData();\n  }\n\n  public destroy(): void {\n    this._resetData();\n    this._unbind();\n    this.history.clear();\n    this.hooks.clear();\n    this.plugins = [];\n  }\n\n  get data(): ITransitionData {\n    return this._data;\n  }\n\n  get wrapper(): HTMLElement {\n    return this._wrapper;\n  }\n\n  /**\n   * ### Force a page change without Barba transition.\n   */\n  public force(href: string): void {\n    // DEV\n    // Can be used waiting animation cancellation management…\n    window.location.assign(href);\n  }\n\n  /**\n   * ### Go for a Barba transition.\n   *\n   * Manage \"self page\" href:\n   *\n   * - if same url and no self transition, keep default behavior\n   *   - link: reload the page\n   *   - anchor: scroll to\n   * - if same url with self transition, use it\n   * - then start a page transition.\n   */\n  public go(\n    href: string,\n    trigger: Trigger = 'barba',\n    e?: LinkEvent | PopStateEvent\n  ): Promise<void> {\n    // If animation running, force reload\n    if (this.transitions.isRunning) {\n      this.force(href);\n\n      return;\n    }\n\n    let self = false;\n\n    // Check prevent sameURL against current history\n    if (trigger === 'popstate') {\n      self =\n        this.history.current &&\n        this.url.getPath(this.history.current.url) === this.url.getPath(href);\n    } else {\n      self = this.prevent.run('sameUrl', null, null, href);\n    }\n\n    if (self && !this.transitions.hasSelf) {\n      return;\n    }\n\n    // Manage history / popstate direction\n    if (trigger === 'popstate') {\n      const { state } = e as PopStateEvent;\n      // Get direction\n      trigger = this.history.getDirection(state.index as number);\n      this.history.add(href, state.ns, state.index, false);\n    } else {\n      this.history.add(href, 'tmp');\n    }\n\n    if (e) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n\n    return this.page(href, trigger, self);\n  }\n\n  /**\n   * ### Start an \"appear\" transition.\n   *\n   * If some registered \"appear\" transition,\n   * get the \"resolved\" transition from the store and start it.\n   */\n  public async appear(readyData: ITransitionData): Promise<void> {\n    await this.hooks.do('beforeEnter', readyData);\n\n    // Check if appear transition\n    if (this.transitions.hasAppear) {\n      try {\n        const transition = this.transitions.get(readyData, {\n          appear: true,\n        }) as ITransitionAppear;\n\n        await this.transitions.doAppear({ transition, data: readyData });\n      } catch (error) {\n        this.logger.error(error);\n      }\n    }\n\n    await this.hooks.do('afterEnter', readyData);\n  }\n\n  /**\n   * ### Start a \"page\" transition.\n   *\n   * 1. If no running transition, updates data with full URL properties and trigger.\n   * 2. Get page from cache or init request.\n   * 3. Wait if some transitions need \"next\" data (`sync: true`, `to: …`).\n   * 4. Manage the history, depending on trigger.\n   * 5. Get \"data\" and trigger \"go\" hook.\n   * 6. Get the \"resolved\" transition from the store and start it.\n   * 7. Update title and reset data (current, next = undefined).\n   *\n   * > If \"self\", use the \"self\" transition\n   */\n  public async page(\n    href: string,\n    trigger: Trigger,\n    self: boolean\n  ): Promise<void> {\n    this.data.next.url = {\n      href,\n      ...this.url.parse(href),\n    };\n    this.data.trigger = trigger;\n\n    const page = this.cache.has(href)\n      ? this.cache.update(href, { action: 'click' }).request\n      : this.cache.set(\n          href,\n          this.request(\n            href,\n            this.timeout,\n            this.onRequestError.bind(this, trigger)\n          ),\n          'click'\n        ).request;\n\n    // Need to wait before getting the right transition\n    if (this.transitions.shouldWait) {\n      await helpers.update(page, this.data);\n    }\n\n    const data = this.data;\n\n    // Hook: between trigger and transition\n    // Can be used to resolve \"route\"…\n    await this.hooks.do('page', data);\n\n    try {\n      const transition = this.transitions.get(data, {\n        appear: false,\n        self,\n      }) as ITransitionPage;\n\n      await this.transitions.doPage({\n        data,\n        page,\n        transition,\n        wrapper: this._wrapper,\n      });\n\n      this._resetData();\n    } catch (error) {\n      // Something went wrong (rejected promise, error, 404, 505, other…)\n      this.logger.error(error);\n    }\n  }\n\n  /**\n   * When a request error occurs.\n   *\n   * Allow the user to manage request error. (E.g: 404)\n   */\n  public onRequestError(trigger: Trigger, ...args: any): boolean {\n    // Cancel transition status\n    this.transitions.isRunning = false;\n\n    const [href, response]: [string, RequestErrorOrResponse] = args;\n    const action = this.cache.getAction(href);\n    this.cache.delete(href);\n\n    // Custom requestError returning false will return here.\n    if (\n      this._requestCustomError &&\n      this._requestCustomError(trigger, action, href, response) === false\n    ) {\n      return false;\n    }\n\n    // Force page change\n    if (action === 'click') {\n      this.force(href);\n    }\n    return false;\n  }\n\n  /**\n   * Programmatically prefetch\n   */\n  public prefetch(href: string) {\n    // Already in cache\n    /* istanbul ignore next */\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, 'barba')\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'prefetch'\n    );\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _bind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.addEventListener('mouseover', this._onLinkEnter);\n      document.addEventListener('touchstart', this._onLinkEnter);\n    }\n    document.addEventListener('click', this._onLinkClick);\n    window.addEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * Bind event listeners.\n   */\n  private _unbind(): void {\n    /* istanbul ignore else */\n    if (this.prefetchIgnore !== true) {\n      document.removeEventListener('mouseover', this._onLinkEnter);\n      document.removeEventListener('touchstart', this._onLinkEnter);\n    }\n    document.removeEventListener('click', this._onLinkClick);\n    window.removeEventListener('popstate', this._onStateChange);\n  }\n\n  /**\n   * When a element is entered.\n   *\n   * Get valid link element.\n   * Cache URL if needed.\n   */\n  private _onLinkEnter(e: LinkEvent): void {\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    const href = this.dom.getHref(link);\n\n    if (this.prevent.checkUrl(href)) {\n      return;\n    }\n\n    // Already in cache\n    if (this.cache.has(href)) {\n      return;\n    }\n\n    this.cache.set(\n      href,\n      this.request(\n        href,\n        this.timeout,\n        this.onRequestError.bind(this, link)\n      ).catch((error: RequestErrorOrResponse) => {\n        this.logger.error(error);\n      }),\n      'enter'\n    );\n  }\n\n  /**\n   * When an element is clicked.\n   *\n   * Get valid link element.\n   * Prevent same URL.\n   * Go for a Barba transition.\n   */\n  private _onLinkClick(e: LinkEvent): void {\n    // This use `prevent.checkLink` under the hood to get eligible link.\n    const link = this._getLinkElement(e);\n\n    if (!link) {\n      return;\n    }\n\n    this.go(this.dom.getHref(link), link, e);\n  }\n\n  /**\n   * When History state changes.\n   *\n   * Get \"href\" from URL\n   * Go for a Barba transition.\n   */\n  private _onStateChange(e: PopStateEvent): void {\n    this.go(this.url.getPath(this.url.getHref()), 'popstate', e);\n  }\n\n  /**\n   * Get a valid link ancestor.\n   *\n   * Check for a \"href\" attribute.\n   * Then check if eligible for Barba.\n   */\n  private _getLinkElement(e: LinkEvent): Link {\n    let el = e.target as Link;\n\n    while (el && !this.dom.getHref(el)) {\n      el = (el as HTMLElement).parentNode as Link;\n    }\n\n    // Check prevent\n    if (!el || this.prevent.checkLink(el, e, this.dom.getHref(el))) {\n      return;\n    }\n\n    return el;\n  }\n\n  /**\n   * Reset pages data.\n   *\n   * Set \"current\" and unset \"next\".\n   */\n  private _resetData() {\n    const href = this.url.getPath(this.url.getHref());\n    const current = {\n      container: this.dom.getContainer(),\n      html: this.dom.getHtml(),\n      namespace: this.dom.getNamespace(),\n      url: {\n        href,\n        ...this.url.parse(href),\n      },\n    };\n\n    this._data = {\n      current,\n      next: { ...this.schemaPage },\n      trigger: undefined,\n    };\n\n    this.hooks.do('reset', this.data);\n  }\n}\n\nconst core = new Core();\n\nexport default core;\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_catch","body","recover","const","_earlyReturn","_AsyncGenerator","entry","_entry","_pact","_resolve","_return","_promise","_wrapReturnedValue","done","_wrapYieldedValue","Symbol","asyncIterator","_yield","next","Promise","resolve","returnValue","error","return","throw","reject","LogLevels","runAsync","module","func","cb","async","args","arguments","promise","obj","answer","apply","err","Array","slice","call","length","push","let","_level","off","Logger","constructor","source","_source","getLevel","setLevel","name","_log","console","objects","warn","warning","info","debug","log","fn","level","concat","Hooks","Map","init","registered","clear","all","forEach","hook","ctx","has","set","Set","get","add","do","chain","help","logger","join","key","hooks","pathToRegexp","path","keys","options","RegExp","groups","match","i","prefix","delimiter","optional","repeat","pattern","regexpToRegexp","isArray","parts","flags","arrayToRegexp","tokensToRegExp","parse","stringToRegexp","tokensToFunction","DEFAULT_DELIMITER","PATH_REGEXP","str","res","tokens","index","defaultDelimiter","whitelist","undefined","pathEscaped","exec","m","escaped","offset","prev","capture","group","modifier","k","c","indexOf","escapeGroup","escapeString","substr","matches","data","encode","encodeURIComponent","token","segment","TypeError","j","test","String","replace","sensitive","strict","start","end","endsWith","map","route","endToken","isEndDelimited","schemaAttribute","container","namespace","prevent","wrapper","Dom","DOMParser","toString","el","outerHTML","toDocument","htmlString","_parser","parseFromString","toElement","div","document","createElement","innerHTML","getHtml","doc","documentElement","getWrapper","scope","querySelector","_attr","getContainer","removeContainer","contains","_sibling","nextElementSibling","parentNode","removeChild","addContainer","insertBefore","appendChild","getNamespace","ns","getAttribute","getHref","tagName","toLowerCase","href","baseVal","dom","History","url","scroll","x","window","scrollX","y","scrollY","_state","history","replaceState","size","pushState","remove","pop","update","Object","current","cancel","back","getDirection","direction","prototypeAccessors","previous","page","html","nextDocument","title","ptr","requestAnimationFrame","getOrigin","location","origin","getPort","p","port","parseInt","protocol","hash","query","hashIndex","queryIndex","parseQuery","split","reduce","acc","clean","Ignore","ignore","_ignoreAll","paths","_ignoreRegexes","checkUrl","some","regex","Cache","request","action","getRequest","getAction","delete","ttl","requestError","xhr","XMLHttpRequest","onreadystatechange","readyState","DONE","status","responseText","statusText","ontimeout","Error","onerror","open","timeout","setRequestHeader","send","exists","ref","newTab","event","which","metaKey","ctrlKey","shiftKey","altKey","blank","hasAttribute","target","corsDomain","hostname","corsPort","download","preventSelf","preventAll","Boolean","closest","sameUrl","Prevent","check","suite","tests","run","checkLink","Store","transitions","type","_rules","splice","position","filters","appear","filter","self","t","matching","active","find","valid","reverse","rule","_check","from","to","activeMatch","transitionType","infos","_addPriority","sort","a","b","priority","transition","isValid","hasMatch","strRule","objRule","fnName","base","names","_calculatePriority","ruleName","ruleIndex","Math","pow","Transitions","store","isRunning","_running","hasAppear","hasSelf","shouldWait","sync","doAppear","_doAsyncHook","doPage","_this2","leave","enter","leaveResult","helpers","values","Views","views","view","byNamespace","_createHook","Element","msMatchesSelector","webkitMatchesSelector","parentElement","nodeType","schemaPage","Core","use","plugin","installedPlugins","plugins","install","logLevel","version","schema","_requestCustomError","cacheIgnore","prefetchIgnore","_wrapper","setAttribute","_resetData","cache","preventCustom","_onLinkEnter","_onLinkClick","_onStateChange","_bind","readyData","trigger","destroy","_unbind","_data","force","assign","go","getPath","stopPropagation","preventDefault","onRequestError","response","prefetch","catch","addEventListener","removeEventListener","link","_getLinkElement","core"],"mappings":"AACA,IAAaA,EAAS,oBACZA,YACTA,EAAMC,UAAUC,KAAO,SAASC,EAAaC,OACtCC,EAAS,IAAIL,EACbM,EAAQC,KAAKC,KACfF,EAAO,KACJG,EAAmB,EAARH,EAAYH,EAAcC,KACvCK,EAAU,KAEZC,EAAQL,EAAQ,EAAGI,EAASF,KAAKI,IAChC,MAAOC,GACRF,EAAQL,EAAQ,EAAGO,UAEbP,SAEAE,iBAGJM,EAAI,SAASC,WAEVC,EAAQD,EAAMH,EACN,EAAVG,EAAMN,EACTE,EAAQL,EAAQ,EAAGF,EAAcA,EAAYY,GAASA,GAC5CX,EACVM,EAAQL,EAAQ,EAAGD,EAAWW,IAE9BL,EAAQL,EAAQ,EAAGU,GAEnB,MAAOH,GACRF,EAAQL,EAAQ,EAAGO,KAGdP,GAEDL,EAlCc,GAsCtB,SAAgBU,EAAQM,EAAMV,EAAOS,OAC/BC,EAAKR,EAAG,IACRO,aAAiBf,EAAO,KACvBe,EAAMP,cAMTO,EAAMF,EAAIH,EAAQO,KAAK,KAAMD,EAAMV,IALvB,EAARA,IACHA,EAAQS,EAAMP,GAEfO,EAAQA,EAAMJ,KAMZI,GAASA,EAAMb,iBAClBa,EAAMb,KAAKQ,EAAQO,KAAK,KAAMD,EAAMV,GAAQI,EAAQO,KAAK,KAAMD,EAAM,IAGtEA,EAAKR,EAAIF,EACTU,EAAKL,EAAII,MACHG,EAAWF,EAAKH,EAClBK,GACHA,EAASF,IAwfL,SAASG,EAAOC,EAAMC,WAEvBhB,EAASe,IACZ,MAAMR,UACAS,EAAQT,UAEZP,GAAUA,EAAOH,KACbG,EAAOH,UAAK,EAAQmB,GAErBhB,EAyCDiB,IAAMC,EAAe,IAaI,oBACtBC,EAAgBC,QACnBC,EAASD,OACTE,EAAQ,UACRC,EAAW,UACXC,EAAU,UACVC,EAAW,cAGRC,EAAmBhB,SACpB,CAAEA,MAAOA,EAAOiB,MAAM,YAErBC,EAAkBlB,SACnB,CAAEA,MAAOA,EAAOiB,MAAM,GAG9BR,EAAgBvB,UAAUiC,OAAOC,gBAAkBD,OAAOC,cAAgBD,OAAO,0BAA4B,kBACrG3B,MAERiB,EAAgBvB,UAAUmC,EAAS,SAASrB,eAEtCa,EAASb,GAASA,EAAMb,KAAOa,EAAMb,KAAK+B,GAAqBA,EAAkBlB,IAE/ER,KAAKoB,EAAQ,IAAI3B,GAEzBwB,EAAgBvB,UAAUoC,KAAO,SAAStB,OAEnCD,EAAQP,YACPO,EAAMgB,EAAW,IAAIQ,QAAQ,SAAUC,OACvCZ,EAAQb,EAAMa,KACN,OAAVA,EAAgB,KACbD,EAASZ,EAAMY,KACN,OAAXA,SAGIa,EAAQzB,EAAMgB,YAKbU,EAAYzB,GACpBD,EAAMc,EAASb,GAASA,EAAMb,KAAOa,EAAMb,KAAK6B,GAAsBA,EAAmBhB,IACzFD,EAAMa,EAAQ,KACdb,EAAMc,EAAW,KALlBd,EAAMY,EAAS,KACfZ,EAAMc,EAAWW,EAMjBb,EAAOZ,GAAOZ,KAAKsC,EAAa,SAASC,MACpCA,IAAUlB,EACbiB,EAAY1B,EAAMe,OACZ,KACAb,EAAO,IAAIhB,EACjBc,EAAMc,EAASZ,GACfF,EAAMa,EAAQ,KACdb,EAAMc,EAAW,KACjBA,SAASZ,EAAM,EAAGyB,WAKpB3B,EAAMa,EAAQ,KACdb,EAAMc,EAAWW,EACjB7B,EAAQiB,EAAO,EAAGZ,MAIrBS,EAAgBvB,UAAUyC,OAAS,SAAS3B,OAErCD,EAAQP,YACPO,EAAMgB,EAAW,IAAIQ,QAAQ,SAAUC,OACvCZ,EAAQb,EAAMa,KACN,OAAVA,SACkB,OAAjBb,EAAMY,EAGFa,EAAQzB,EAAMgB,IAGtBhB,EAAMY,EAAS,KACRa,EAAQxB,GAASA,EAAMb,KAAOa,EAAMb,KAAK6B,GAAsBA,EAAmBhB,KAG1FD,EAAMe,EAAUd,EAChBD,EAAMc,EAAWW,EACjBzB,EAAMa,EAAQ,KACdjB,EAAQiB,EAAO,EAAGJ,MAGpBC,EAAgBvB,UAAU0C,MAAQ,SAASF,OAEpC3B,EAAQP,YACPO,EAAMgB,EAAW,IAAIQ,QAAQ,SAAUC,EAASK,OAChDjB,EAAQb,EAAMa,KACN,OAAVA,SACkB,OAAjBb,EAAMY,EAGFa,EAAQzB,EAAMgB,IAGtBhB,EAAMY,EAAS,KACRkB,EAAOH,IAGf3B,EAAMc,EAAWW,EACjBzB,EAAMa,EAAQ,KACdjB,EAAQiB,EAAO,EAAGc,MAxGW,GCnnBhC,ICsBYI,yCCNRC,EAAWC,UAAiB,SAAUC,EAAMC,UAC9CA,EAAKA,GAAM,aAEJ,eACDC,GAAQ,EACRC,EAAOC,UAEPC,EAAU,IAAIf,QAAQ,SAAUC,EAASK,OFrB9BU,EEsBTC,EAASP,EAAKQ,MAAM,CACtBN,MAAO,kBACLA,GAAQ,EACD,SAAUO,EAAK1C,GAChB0C,EACFb,EAAOa,GAEPlB,EAAQxB,MAIb2C,MAAMzD,UAAU0D,MAAMC,KAAKT,IAEzBD,MFnCQI,EEoCGC,IFnCY,iBAARD,GAAmC,mBAARA,GAA2C,mBAAbA,EAAIpD,KEsC7EqC,EAAQgB,GAFRA,EAAOrD,KAAKqC,EAASK,aAO3BS,EAAQnD,KAAK+C,EAAGhC,KAAK,KAAM,MAAOgC,GAE3BI,IAIXP,EAASG,GAAK,SAAUD,EAAMC,UACrBH,EAAS,eACVK,EAAOO,MAAMzD,UAAU0D,MAAMC,KAAKR,kBAClCD,EAAKU,SAAWb,EAAKa,OAAS,GAChCV,EAAKW,KAAKvD,KAAK2C,SAEVF,EAAKQ,MAAMjD,KAAM4C,IACvBF,mCDrCL,SAAYJ,GACVA,iBACAA,qBACAA,yBACAA,mBACAA,qBALF,CAAYA,IAAAA,OAWZkB,IAAIC,EAAiBnB,EAAUoB,IAElBC,EAyBXC,SAAYC,QACLC,EAAUD,GAaV3B,EAnCO6B,2BACLN,KAMKO,kBAASC,UACrBR,EAASnB,EAAU2B,gBA2Bd/B,6EACAgC,EAAKC,QAAQjC,MAAOI,EAAUJ,MAAOkC,IAMrCC,YAAAA,4EACAH,EAAKC,QAAQE,KAAM/B,EAAUgC,QAASF,IAMtCG,YAAAA,4EACAL,EAAKC,QAAQI,KAAMjC,EAAUiC,KAAMH,IAMnCI,YAAAA,6EACAN,EAAKC,QAAQM,IAAKnC,EAAUkC,MAAOJ,IAMlCF,YAAAA,WAAKQ,EAAgBC,EAAeP,GACtCO,GAAShB,EAAOI,YAClBW,EAAGzB,MAAMkB,QAAU,KAAKnE,aAAkB4E,OAAOR,SEzE1CS,EA4CXjB,uBAtCwB,IAAID,EAAO,wBAOV,CACvB,QACA,OACA,QACA,eACA,iBACA,YACA,cACA,eACA,SACA,cACA,iBACA,SACA,cACA,QACA,aACA,gBACA,cACA,QACA,aACA,gBACA,yBAQiD,IAAImB,SAGhDC,QAGAA,YAAAA,gCACAC,WAAWC,aACXC,IAAIC,iBAAQC,GACVpF,EAAKoF,OACHA,YAASV,EAAyBW,kBAAW,MAC3CrF,EAAKgF,WAAWM,IAAIF,MAClBJ,WAAWO,IAAIH,EAAM,IAAII,KAEpBxF,EAAKgF,WAAWS,IAAIL,GAE5BM,IAAI,KACNL,KACAX,SAYHiB,YAAAA,YAAG1B,oEACJjE,KAAKgF,WAAWM,IAAIrB,GAAO,KAEzB2B,EAAQ7D,QAAQC,sBAEfgD,WAAWS,IAAIxB,GAAMkB,iBAAQC,OAE1BV,EAAKU,EAAKC,IAAMD,EAAKV,GAAGhE,KAAK0E,EAAKC,KAAOD,EAAKV,GAEpDkB,EAAQA,EAAMjG,uBAAW4C,EAASmC,cAAI,EAAG9B,OAGpCgD,SAGF7D,QAAQC,WAGViD,YAAAA,iCACAC,IAAIC,iBAAQC,UACRpF,EAAKoF,UAGTL,QAMAc,YAAAA,qBACAC,OAAOvB,yBAAyBvE,KAAKkF,IAAIa,KAAK,UAC7Cf,EAAuB,QACxBA,WAAWG,iBAAS3E,EAAOwF,UAAQhB,EAAWzB,KAAKyC,UACnDF,OAAOvB,0BAA0BS,EAAWe,KAAK,OAI1DhF,IAAMkF,EAAQ,IAAIpB,ICwNlB,SAASqB,EAAcC,EAAMC,EAAMC,UAC7BF,aAAgBG,OA7HtB,SAAyBH,EAAMC,OACxBA,EAAM,OAAOD,MAGdI,EAASJ,EAAKtC,OAAO2C,MAAM,gBAE3BD,MACG,IAAIE,EAAI,EAAGA,EAAIF,EAAOjD,OAAQmD,IACjCL,EAAK7C,KAAK,CACRU,KAAMwC,EACNC,OAAQ,KACRC,UAAW,KACXC,UAAU,EACVC,QAAQ,EACRC,QAAS,cAKRX,EA2GEY,CAAeZ,EAAMC,GAG1BjD,MAAM6D,QAAQb,GAnGpB,SAAwBA,EAAMC,EAAMC,WAC9BY,EAAQ,GAEHR,EAAI,EAAGA,EAAIN,EAAK7C,OAAQmD,IAC/BQ,EAAM1D,KAAK2C,EAAaC,EAAKM,GAAIL,EAAMC,GAASxC,eAG3C,IAAIyC,OAAO,MAAQW,EAAMlB,KAAK,KAAO,IAAKmB,EAAMb,IA6F9Cc,CAAqChB,EAAOC,EAAMC,GAlF7D,SAAyBF,EAAMC,EAAMC,UAC5Be,EAAeC,EAAMlB,EAAME,GAAUD,EAAMC,GAoF3CiB,CAAsCnB,EAAOC,EAAMC,MAzWrCgB,IAEWE,IACFH,EAK5BI,EAAoB,IAOpBC,EAAc,IAAInB,OAAO,CAG3B,UAMA,uFACAP,KAAK,KAAM,KASb,SAASsB,EAAOK,EAAKrB,WAQfsB,EAPAC,EAAS,GACT5B,EAAM,EACN6B,EAAQ,EACR1B,EAAO,GACP2B,EAAoBzB,GAAWA,EAAQM,WAAca,EACrDO,EAAa1B,GAAWA,EAAQ0B,gBAAcC,EAC9CC,GAAc,EAGuB,QAAjCN,EAAMF,EAAYS,KAAKR,KAAgB,KACzCS,EAAIR,EAAI,GACRS,EAAUT,EAAI,GACdU,EAASV,EAAIE,SACjB1B,GAAQuB,EAAItE,MAAMyE,EAAOQ,GACzBR,EAAQQ,EAASF,EAAE7E,OAGf8E,EACFjC,GAAQiC,EAAQ,GAChBH,GAAc,WAIZK,EAAO,GACPrE,EAAO0D,EAAI,GACXY,EAAUZ,EAAI,GACda,EAAQb,EAAI,GACZc,EAAWd,EAAI,OAEdM,GAAe9B,EAAK7C,OAAQ,KAC3BoF,EAAIvC,EAAK7C,OAAS,EAClBqF,EAAIxC,EAAKuC,KACCX,GAAYA,EAAUa,QAAQD,IAAM,KAGhDL,EAAOK,EACPxC,EAAOA,EAAK/C,MAAM,EAAGsF,IAKrBvC,IACFyB,EAAOrE,KAAK4C,GACZA,EAAO,GACP8B,GAAc,OAKZnB,EAAUyB,GAAWC,EACrB7B,EAAY2B,GAAQR,EAExBF,EAAOrE,KAAK,CACVU,KAAMA,GAAQ+B,IACdU,OAAQ4B,EACR3B,UAAWA,EACXC,SAR0B,MAAb6B,GAAiC,MAAbA,EASjC5B,OAVwB,MAAb4B,GAAiC,MAAbA,EAW/B3B,QAASA,EACL+B,EAAY/B,GACZ,KAAOgC,EAAanC,IAAcmB,EAAmBnB,EAAaA,EAAYmB,GAAqB,gBAKvG3B,GAAQ0B,EAAQH,EAAIpE,SACtBsE,EAAOrE,KAAK4C,EAAOuB,EAAIqB,OAAOlB,IAGzBD,EAiBT,SAASL,EAAkBK,WAErBoB,EAAU,IAAI7F,MAAMyE,EAAOtE,QAGtBmD,EAAI,EAAGA,EAAImB,EAAOtE,OAAQmD,IACR,iBAAdmB,EAAOnB,KAChBuC,EAAQvC,GAAK,IAAIH,OAAO,OAASsB,EAAOnB,GAAGK,QAAU,cAIlD,SAAUmC,EAAM5C,WACjBF,EAAO,GACP+C,EAAU7C,GAAWA,EAAQ6C,QAAWC,mBAEnC1C,EAAI,EAAGA,EAAImB,EAAOtE,OAAQmD,IAAK,KAClC2C,EAAQxB,EAAOnB,MAEE,iBAAV2C,OAMPC,EADA7I,EAAQyI,EAAOA,EAAKG,EAAMnF,WAAQ+D,KAGlC7E,MAAM6D,QAAQxG,QACX4I,EAAMvC,aACH,IAAIyC,UAAU,aAAeF,EAAMnF,KAAO,qCAG7B,IAAjBzD,EAAM8C,OAAc,IAClB8F,EAAMxC,SAAU,eAEd,IAAI0C,UAAU,aAAeF,EAAMnF,KAAO,yBAG7C,IAAIsF,EAAI,EAAGA,EAAI/I,EAAM8C,OAAQiG,IAAK,IACrCF,EAAUH,EAAO1I,EAAM+I,GAAIH,IAEtBJ,EAAQvC,GAAG+C,KAAKH,SACb,IAAIC,UAAU,iBAAmBF,EAAMnF,KAAO,eAAiBmF,EAAMtC,QAAU,KAGvFX,IAAe,IAANoD,EAAUH,EAAM1C,OAAS0C,EAAMzC,WAAa0C,WAMpC,iBAAV7I,GAAuC,iBAAVA,GAAuC,kBAAVA,OAWjE4I,EAAMxC,eAEJ,IAAI0C,UAAU,aAAeF,EAAMnF,KAAO,YAAcmF,EAAMvC,OAAS,WAAa,qBAZxFwC,EAAUH,EAAOO,OAAOjJ,GAAQ4I,IAE3BJ,EAAQvC,GAAG+C,KAAKH,SACb,IAAIC,UAAU,aAAeF,EAAMnF,KAAO,eAAiBmF,EAAMtC,QAAU,eAAiBuC,EAAU,KAG9GlD,GAAQiD,EAAM1C,OAAS2C,QAtCvBlD,GAAQiD,SA+CLjD,GAUX,SAAS2C,EAAcpB,UACdA,EAAIgC,QAAQ,6BAA6B,QASlD,SAASb,EAAaL,UACbA,EAAMkB,QAAQ,gBAAgB,QASvC,SAASxC,EAAOb,UACPA,GAAWA,EAAQsD,UAAY,GAAK,IAsE7C,SAASvC,EAAgBQ,EAAQxB,EAAMC,WAGjCuD,GAFJvD,EAAUA,GAAW,IAEAuD,OACjBC,GAA0B,IAAlBxD,EAAQwD,MAChBC,GAAsB,IAAhBzD,EAAQyD,IACdnD,EAAYN,EAAQM,WAAaa,EACjCuC,EAAW,GAAGnF,OAAOyB,EAAQ0D,UAAY,IAAIC,IAAIlB,GAAclE,OAAO,KAAKmB,KAAK,KAChFkE,EAAQJ,EAAQ,IAAM,GAGjBpD,EAAI,EAAGA,EAAImB,EAAOtE,OAAQmD,IAAK,KAClC2C,EAAQxB,EAAOnB,MAEE,iBAAV2C,EACTa,GAASnB,EAAaM,OACjB,KACDb,EAAUa,EAAMvC,OAChB,MAAQuC,EAAMtC,QAAU,OAASgC,EAAaM,EAAMzC,WAAa,MAAQyC,EAAMtC,QAAU,MACzFsC,EAAMtC,QAENV,GAAMA,EAAK7C,KAAK6F,GAMhBa,GAJAb,EAAMxC,SACHwC,EAAM1C,OAGA,MAAQoC,EAAaM,EAAM1C,QAAU,IAAM6B,EAAU,MAFrD,IAAMA,EAAU,KAKlBO,EAAaM,EAAM1C,QAAU,IAAM6B,EAAU,QAKxDuB,EACGF,IAAQK,GAAS,MAAQnB,EAAanC,GAAa,MAExDsD,GAAsB,MAAbF,EAAmB,IAAM,MAAQA,EAAW,QAChD,KACDG,EAAWtC,EAAOA,EAAOtE,OAAS,GAClC6G,EAAqC,iBAAbD,EACxBA,EAASA,EAAS5G,OAAS,KAAOqD,OACrBqB,IAAbkC,EAECN,IAAQK,GAAS,MAAQnB,EAAanC,GAAa,MAAQoD,EAAW,OACtEI,IAAgBF,GAAS,MAAQnB,EAAanC,GAAa,IAAMoD,EAAW,YAG5E,IAAIzD,OAAO2D,EAAO/C,EAAMb,wBA/NjC,SAAkBqB,EAAKrB,UACdkB,EAAiBF,EAAMK,EAAKrB,6CCtGrC,IAAa+D,EAAoC,CAC/CC,UAAW,YACXC,UAAW,YACX5D,OAAQ,aACR6D,QAAS,UACTC,QAAS,WCHEC,EAAb7G,kBACoCwG,SACL,IAAIM,iBACD,MAKzBC,YAAAA,kBAASC,UACPA,EAAGC,WAQLC,YAAAA,oBAAWC,UACT/K,KAAKgL,EAAQC,gBAAgBF,EAAY,cAS3CG,YAAAA,mBAAUH,OACTI,EAAMC,SAASC,cAAc,cAEnCF,EAAIG,UAAYP,EACTI,GAMFI,YAAAA,iBAAQC,yBAAoBJ,UAC1BpL,KAAK2K,SAASa,EAAIC,kBAapBC,YAAAA,oBAAWC,yBAAeP,UACxBO,EAAMC,kBACP5L,KAAK6L,cAAiB7L,KAAK6L,iBAO5BC,YAAAA,sBAAaH,yBAAeP,UAC1BO,EAAMC,kBACP5L,KAAK6L,cAAiB7L,KAAK6L,mBAO5BE,YAAAA,yBAAgB1B,GACjBe,SAASvK,KAAKmL,SAAS3B,UACpB4B,EAAW5B,EAAU6B,qBAChBC,WAAWC,YAAY/B,KAO9BgC,YAAAA,sBAAahC,EAAwBG,GACtCxK,KAAKiM,IACCK,aAAajC,EAAWrK,KAAKiM,GAErCzB,EAAQ+B,YAAYlC,IAOjBmC,YAAAA,sBAAab,kBAAeP,cAC3BqB,EAAKd,EAAMC,kBACX5L,KAAK6L,aAAgB7L,KAAK6L,wBAGzBY,EACHA,EAAGC,aAAgB1M,KAAK6L,aAAgB7L,KAAK6L,aAC7C,MAMCc,YAAAA,iBAAQ/B,MAETA,EAAGgC,SAAwC,MAA7BhC,EAAGgC,QAAQC,cAAuB,KAC5CC,EAAOlC,EAAG8B,aAAa,WAEzBI,SAEOA,EAAuCC,SAAWD,SAGxD,MAIX/L,IAAMiM,EAAM,IAAIvC,ECjGHwC,EAAbrJ,kBACmC,oFAK1BmB,YAAAA,cAAKmI,EAAaT,OACjB1M,EAAsB,OACnB,KACP0M,EACAU,OAAQ,CACNC,EAAGC,OAAOC,QACVC,EAAGF,OAAOG,aAEZN,QAGGO,EAAOlK,KAAKxD,GACjBsN,OAAOK,SAAWL,OAAOK,QAAQC,aAAa5N,EAAO,GAAIA,EAAMmN,MAM1DxH,YAAAA,aACLwH,EACAT,EACAhG,EACAlD,kBADY,sBACI,OAGVxD,EAAsB,OADd0G,GAAKzG,KAAK4N,QAGtBnB,EACAU,OAAQ,CACNC,EAAGC,OAAOC,QACVC,EAAGF,OAAOG,aAEZN,QAGGO,EAAOlK,KAAKxD,GAEbwD,GACF8J,OAAOK,SAAWL,OAAOK,QAAQG,UAAU9N,EAAO,GAAIA,EAAMmN,MAOzDY,YAAAA,uBACAL,EAAOM,OAMP9I,YAAAA,sBACAwI,EAAS,IAMTO,YAAAA,gBAAO/E,OACNlJ,EAAsBkO,iBACvBjO,KAAKkO,gBAILA,QAAUnO,EACfsN,OAAOK,SAAWL,OAAOK,QAAQC,aAAa5N,EAAO,GAAIA,EAAMmN,MAM1DiB,YAAAA,uBACAL,gBAEEJ,SAAWL,OAAOK,QAAQU,QAM5B3I,YAAAA,aAAIoC,UACF7H,KAAKyN,EAAO5F,IAGdwG,YAAAA,sBAAaxG,OACdyG,EAAqB,kBAErBzG,EAAQ7H,KAAKkO,QAAQrG,QACX,OACHA,EAAQ7H,KAAKkO,QAAQrG,UAClB,WAGPyG,GAMTC,EAAIL,8BACKlO,KAAKyN,EAAOzN,KAAKyN,EAAOnK,OAAS,MAGtC4K,qBAAQnO,QACL0N,EAAOzN,KAAKyN,EAAOnK,OAAS,GAAKvD,GAMxCwO,EAAIC,+BACKxO,KAAKyN,EAAOnK,OAAS,EAAI,KAAOtD,KAAKyN,EAAOzN,KAAKyN,EAAOnK,OAAS,IAM1EiL,EAAIX,2BACK5N,KAAKyN,EAAOnK,+CAIvBvC,IAAM2M,EAAU,IAAIT,EC/IPe,WACXS,EACAxF,4BAGKA,EAAKnH,KAAK4M,4BACMD,iBAAbC,mBAGFA,OAGIC,EAAe3B,EAAI9B,UAAUwD,GAEnC5M,EAAKwI,UAAY0C,EAAIR,aAAamC,GAClC7M,EAAKuI,UAAY2C,EAAIlB,aAAa6C,GAIlC7M,EAAK4M,KAAOA,EAGZhB,EAAQM,OAAO,CAAEvB,GAAI3K,EAAKwI,kBAGR0C,EAAIlC,WAAW4D,GAEjCtD,SAASwD,sHAyBT1I,EAAe2I,yCAhBnB,IAAI9M,iBAAQC,GACVqL,OAAOyB,sBAAsB9M,sBCvCpB+M,oBAA0B1B,OAAO2B,SAASC,QAK1CC,WAAWC,OAChBC,EAAOD,GAAK9B,OAAO2B,SAASI,OACb/B,OAAO2B,wBAEf,KAATI,EACKC,SAASD,EAAM,IAGP,WAAbE,EACK,IAGF,IAqBIjI,WAAS6F,OAGhBqC,EADApJ,EAAO+G,EAAIxD,QAAQqF,IAAa,IAEhCS,EAAQ,GAENC,EAAYtJ,EAAKyC,QAAQ,KAE3B6G,GAAa,IACfF,EAAOpJ,EAAK/C,MAAMqM,EAAY,GAC9BtJ,EAAOA,EAAK/C,MAAM,EAAGqM,QAGjBC,EAAavJ,EAAKyC,QAAQ,YAE5B8G,GAAc,IAChBF,EAAQG,EAAWxJ,EAAK/C,MAAMsM,EAAa,IAC3CvJ,EAAOA,EAAK/C,MAAM,EAAGsM,IAGhB,MACLH,OACApJ,QACAqJ,IAOSG,WAAcjI,UACzBA,EAAIkI,MAAM,KAAKC,gBAAQC,EAAqBlF,SACrBA,EAAGgF,MAAM,YAE9BE,aAEOA,GACN,KAKQC,WAAS7C,UAAgBA,EAAIxD,QAAQ,kBAAmB,kCArFhC2D,OAAO2B,SAASlC,6CA4B7BI,UAAwB7F,EAAM6F,GAAK/G,oCC1B9C6J,EAIXpM,SAAYqM,aAFuB,GAGX,kBAAXA,OACJC,EAAaD,MACb,KACCE,EAAQhN,MAAM6D,QAAQiJ,GAAUA,EAAS,CAACA,QAE3CG,EAAiBD,EAAMnG,aAAImF,UAAKjJ,EAAaiJ,OAI/CkB,YAAAA,kBAASnD,MACiB,kBAApBlN,KAAKkQ,SACPlQ,KAAKkQ,QAGG7I,EAAM6F,eAEhBlN,KAAKoQ,EAAeE,cAAKC,UAA8B,OAArBA,EAAMrI,KAAK/B,UCzB3CqK,cAGX5M,WAAYqM,eACJA,UAHkC,IAAInL,oGASvCS,aACLuH,EACA2D,EACAC,UAEK1Q,KAAKqQ,SAASvD,SACZW,EAAOlI,IAAIuH,EAAM,QACpB4D,UACAD,IAIG,QACLC,UACAD,gBAOGhL,aAAIqH,UACF9M,KAAKyN,EAAOhI,IAAIqH,gBAMlB6D,oBAAW7D,UACT9M,KAAKyN,EAAOhI,IAAIqH,GAAM2D,qBAMxBG,mBAAU9D,UACR9M,KAAKyN,EAAOhI,IAAIqH,GAAM4D,oBAMxBpL,aAAIwH,UACF9M,KAAKyN,EAAOnI,IAAIwH,gBAMlB+D,gBAAO/D,UACL9M,KAAKyN,EAAOoD,OAAO/D,gBAMrBkB,gBAAOlB,EAAc7D,OACpBlJ,EAAQkO,iBACTjO,KAAKyN,EAAOhI,IAAIqH,kBAGhBW,EAAOlI,IAAIuH,EAAM/M,GAEfA,MAzEgBiQ,GCM3B,SAASS,EACPvD,EACA4D,EACAC,yBADc,KAGP,IAAIhP,iBAASC,EAASK,OACrB2O,EAAM,IAAIC,eAEhBD,EAAIE,iCACEF,EAAIG,aAAeF,eAAeG,QACjB,MAAfJ,EAAIK,OACNrP,EAAQgP,EAAIM,mBACP,GAAIN,EAAIK,OAAQ,KAEf1J,EAAM,CACV0J,OAAQL,EAAIK,OACZE,WAAYP,EAAIO,YAElBR,EAAa7D,EAAKvF,GAClBtF,EAAOsF,KAIbqJ,EAAIQ,yBACItO,EAAM,IAAIuO,wBAAwBX,OACxCC,EAAa7D,EAAKhK,GAClBb,EAAOa,IAET8N,EAAIU,uBACIxO,EAAM,IAAIuO,qBAChBV,EAAa7D,EAAKhK,GAClBb,EAAOa,IAGT8N,EAAIW,KAAK,MAAOzE,GAChB8D,EAAIY,QAAUd,EACdE,EAAIa,iBACF,SACA,mDAEFb,EAAIa,iBAAiB,UAAW,OAChCb,EAAIc,SCtCR/Q,IAAM8M,oBAAiCR,OAAOK,QAAQG,WAKhDkE,WAAwBC,yBAKxBC,WAAwBD,wBAC3BE,EAAwBC,MAAQ,GAChCD,EAAwBE,SACxBF,EAAwBG,SACxBH,EAAwBI,UACxBJ,EAAwBK,QAKrBC,WAAuBR,qBAC3BpH,EAAG6H,aAAa,WAAqC,WAAvB7H,EAAY8H,QAMtCC,WAA4BX,0BACQhK,IAAtC4C,EAAyB0E,UACzBjC,OAAO2B,SAASM,WAAc1E,EAAyB0E,eACjBtH,IAAtC4C,EAAyBgI,UACzBvF,OAAO2B,SAAS4D,WAAchI,EAAyBgI,UAMrDC,WAA0Bb,0BACKhK,IAAlC4C,EAAyBwE,MAC1BlC,MAAkBA,EAAatC,EAAyBwE,OAKpD0D,WAA0Bd,qBAC9BpH,EAAG8B,cAAuD,iBAAhC9B,EAAG8B,aAAa,aAKtCqG,WAA6Bf,eAC9BS,aAAgBrI,aAA0BA,YAKzC4I,WAA4BhB,UAChCiB,aACKC,YAAY9I,aAA0BA,uBAQvC+I,WAAyBnB,UAC7B9E,YAAoBA,EAAUG,OAAO2B,SAASlC,OAEnCsG,cAIXxP,WAAYqM,eACJA,cAJiB,cACiB,IAAInL,SAIvCC,uGAGAA,qBAEAW,IAAI,YAAamI,QACjBnI,IAAI,SAAUqM,QACdrM,IAAI,SAAUuM,QACdvM,IAAI,QAAS8M,QACb9M,IAAI,aAAciN,QAClBjN,IAAI,WAAYmN,QAChBnN,IAAI,WAAYoN,QAChBpN,IAAI,cAAeqN,QACnBrN,IAAI,aAAcsN,QAGlBtN,IAAI,UAAWyN,GAAS,gBAGxBzN,aAAIzB,EAAcoP,EAAqBC,mBAAiB,QACxDC,MAAMhO,IAAItB,EAAMoP,GACrBC,GAAStT,KAAKsT,MAAM/P,KAAKU,gBAMpBuP,aAAIvP,EAAc2G,EAAUsH,EAAcpF,UACxC9M,KAAKuT,MAAM9N,IAAIxB,EAAfjE,CAAqB,IAC1B4K,QACAsH,OACApF,iBAOG2G,mBAAU7I,EAAUsH,EAAcpF,qBAChC9M,KAAKsT,MAAMhD,cAAKrM,UAAQjE,EAAKwT,IAAIvP,EAAM2G,EAAIsH,EAAOpF,SA7ChCkD,GClEhB0D,EAgCX9P,SAAY+P,kBAAiC,gBA/BrB,IAAIhQ,EAAO,wBAIH,eAIK,UASX,CACxB,MACQ,iBACA,WAER,MACQ,cACA,aAQJgQ,SAEGzO,IAAMlF,KAAKkF,IAAIN,OAAO+O,SAExB3F,UAMAtI,YAAAA,aAAIkO,EAA6B3K,UAC9B2K,OACD,YAEEC,EAAOC,OAAO7K,EAAK8K,UAAY,EAAG,EAAG9K,EAAKzI,iBAE5C,0BAGE0E,IAAI3B,KAAK0F,QAIb+E,UAMAhM,YAAAA,iBACLiH,EACA+K,+BAA8B,QAG1BL,EAAcK,EAAQC,OAASjU,KAAKiU,OAASjU,KAAKkF,IAIpDyO,EAAcA,EAAYO,OADxBF,EAAQG,cACuBC,UAAKA,EAAEnQ,MAAmB,SAAXmQ,EAAEnQ,eAEjBmQ,UAAMA,EAAEnQ,MAAmB,SAAXmQ,EAAEnQ,WAI/CoQ,EAAW,IAAIvP,IAIfwP,EAASX,EAAYY,cAAKH,OAC1BI,GAAQ,EACNhO,EAAQ,YAEVwN,EAAQG,MAAmB,SAAXC,EAAEnQ,UAKjB4P,EAAOY,UAAUtP,iBAAQuP,GACxBF,IACFA,EAAQxU,EAAK2U,EAAOP,EAAGM,EAAMzL,EAAMzC,GAE9BwN,EAAQC,SACPG,EAAEQ,MAAQR,EAAES,KACdL,EACExU,EAAK2U,EAAOP,EAAGM,EAAMzL,EAAMzC,EAAO,SAClCxG,EAAK2U,EAAOP,EAAGM,EAAMzL,EAAMzC,EAAO,OAElC4N,EAAEQ,OAASR,EAAES,KACfL,EAAQxU,EAAK2U,EAAOP,EAAGM,EAAMzL,EAAMzC,EAAO,UAEvC4N,EAAEQ,MAAQR,EAAES,KACfL,EAAQxU,EAAK2U,EAAOP,EAAGM,EAAMzL,EAAMzC,EAAO,aAMzCjB,IAAI6O,EAAG5N,GAETgO,KAGHM,EAAcT,EAAS5O,IAAI6O,GAC3BS,EAAiB,MAErBA,EAAexR,KADbyQ,EAAQC,OACU,SAEA,QAElBD,EAAQG,MACVY,EAAexR,KAAK,QAGlBuR,EAAa,KAETE,EAAe,CAACV,GAEtBrG,OAAO7H,KAAK0O,GAAaxR,OAAS,GAAK0R,EAAMzR,KAAKuR,WAE7ChP,QAAOvB,mCACWwQ,EAAehP,KAAK,iBACtCiP,cAGAlP,OAAOvB,6BAA6BwQ,EAAehP,KAAK,iBAGxDuO,GAUFtG,YAAAA,kCAEA9I,IAAMlF,KAAKkF,IACb8E,aAAIoK,UAAKpU,EAAKiV,EAAab,KAC3Bc,cAAMC,EAAGC,UAAMD,EAAEE,SAAWD,EAAEC,WAC9BZ,UACAzK,aAAIoK,iBACIA,EAAEiB,SAEFjB,SAENH,OAASjU,KAAKkF,IAAIgP,gBACrBE,eAAkBpM,IAAboM,EAAEH,UAeHU,YAAAA,WACNW,EACAZ,EACAzL,EACAzC,EACA8H,OAEIiH,GAAU,EACVC,GAAW,EACTpB,EAAIkB,WAEJG,EAAUxR,EACVyR,EAAUzR,EACV0R,EAAS1R,EACT2R,EAAOtH,EAAY8F,EAAE9F,GAAa8F,EAClC3F,EAAqB,OAAdH,EAAqBrF,EAAKnH,KAAOmH,EAAKiF,WACrCI,EAAYsH,GAAQA,EAAK3R,GAAQ2R,EAAK3R,GAGzC,oBAEF,sBAGG4R,EAAkB1S,MAAM6D,QAAQ4O,EAAKH,IACtCG,EAAKH,GACN,CAACG,EAAKH,IAGNhH,EAAKgH,KAA8C,IAAlCI,EAAMjN,QAAQ6F,EAAKgH,SAC3B,IAGyB,IAAlCI,EAAMjN,QAAQ6F,EAAKgH,SACX,aAKT,aAEGI,EAAkB1S,MAAM6D,QAAQ4O,EAAKF,IACtCE,EAAKF,GACN,CAACE,EAAKF,IAGNjH,EAAKiH,KAELjH,EAAKiH,GAASzR,OACyB,IAAvC4R,EAAMjN,QAAQ6F,EAAKiH,GAASzR,WAEjB,IAG8B,IAAvC4R,EAAMjN,QAAQ6F,EAAKiH,GAASzR,WACpB,cAMX,WACC2R,EAAKD,GAAQ1M,MACJ,KAED,EAKZuM,IACElH,KACIA,GAAa9H,EAAM8H,IAAc,GACvC9H,EAAM8H,GAAWrK,GAAQmQ,EAAE9F,GAAWrK,MAEhCA,GAAQmQ,EAAEnQ,WAKfsR,GAWDO,YAAAA,WACN1B,EACA2B,EACAC,OAEIX,EAAW,SAGbjB,EAAE2B,IACD3B,EAAEQ,MAAQR,EAAEQ,KAAKmB,IACjB3B,EAAES,IAAMT,EAAES,GAAGkB,SAEFE,KAAKC,IAAI,GAAIF,GAErB5B,EAAEQ,MAAQR,EAAEQ,KAAKmB,QACP,GAEV3B,EAAES,IAAMT,EAAES,GAAGkB,QACH,IAITV,GAGDJ,YAAAA,WAAab,cACnBA,EAAEiB,SAAW,MACTA,EAAW,cAEVxB,EAAO1O,iBAASuP,EAAMjO,GAIzB4O,GAAYrV,EAAK8V,EAAmB1B,SAFtB3N,EAAI,KAKpB2N,EAAEiB,SAAWA,EAENjB,OC7SE+B,EAKXvS,SAAY+P,kBAAiC,gBAJrB,IAAIhQ,EAAO,uBAEP,OAGrByS,MAAQ,IAAI1C,EAAMC,uHAQlBlO,YAAAA,aACLwD,EACA+K,UAEOhU,KAAKoW,MAAMpU,QAAQiH,EAAM+K,IAMlCzF,EAAI8H,gCACKrW,KAAKsW,KAEVD,uBAAUhF,QACPiF,EAAWjF,GAMlB9C,EAAIgI,gCACKvW,KAAKoW,MAAMnC,OAAO3Q,OAAS,GAMpCiL,EAAIiI,8BACKxW,KAAKoW,MAAMlR,IAAIoL,cAAK8D,SAAgB,SAAXA,EAAEnQ,QAWpCsK,EAAIkI,iCACKzW,KAAKoW,MAAMlR,IAAIoL,cAAK8D,UAAMA,EAAES,KAAOT,EAAES,GAAG5K,OAAUmK,EAAEsC,QAQhDC,YAAAA,kBAAS3E,yCAQpBhS,qBAeKsW,GAAW,MAhBVlC,EAAIkB,GAAc,KACnBgB,GAAW,4CAGR/V,EAAKqW,EAAa,eAAgB3N,EAAMmL,2CACxC7T,EAAK0T,OAAOhL,EAAMmL,2CAClB7T,EAAKqW,EAAa,cAAe3N,EAAMmL,qCACtClS,WACFoU,GAAW,IACXxQ,OAAO5D,MAAMA,GAIZ,IAAIuP,MAAM,kGAgCPoF,YAAAA,gBAAO7E,8DAclBhS,qBAiFKsW,GAAW,MApFVlC,EAAIkB,GAAc,GAClBoB,GAAkB,IAAXtC,EAAEsC,OAAiB,IAE3BJ,GAAW,yDAQRQ,EAAKF,EAAa,SAAU3N,EAAMmL,yDA4DlC0C,EAAKF,EAAa,QAAS3N,EAAMmL,2CAGjC0C,EAAKhJ,OAAO7E,6CA7DdyN,6CAEMI,EAAKpR,IAAIuD,EAAMuB,2CAEfsM,EAAKF,EAAa,cAAe3N,EAAMmL,2CACvC0C,EAAKF,EAAa,cAAe3N,EAAMmL,2CAGvCrS,QAAQmD,IAAI,CAAC4R,EAAKC,MAAM9N,EAAMmL,GAAI0C,EAAKE,MAAM/N,EAAMmL,6CAGnD0C,EAAKF,EAAa,aAAc3N,EAAMmL,2CACtC0C,EAAKF,EAAa,aAAc3N,EAAMmL,mDAKtC,IAAI3C,MAAM,2FA0BI,IAAhBwF,yBACIH,EAAKpR,IAAIuD,EAAMuB,2CAEfsM,EAAKF,EAAa,cAAe3N,EAAMmL,2CACvC0C,EAAKE,MAAM/N,EAAMmL,EAAG6C,2CACpBH,EAAKF,EAAa,aAAc3N,EAAMmL,2FAMxC,IAAI3C,MAAM,wCAlCdwF,GAAmB,wCAGfH,EAAKF,EAAa,cAAe3N,EAAMmL,2CAEzBrS,QAAQmD,IAAI,CAC9B4R,EAAKC,MAAM9N,EAAMmL,GACjB8C,EAAezI,EAAMxF,KACpBtJ,cAAKwX,UAAUA,EAAO,kDAEnBL,EAAKF,EAAa,aAAc3N,EAAMmL,6CAOtC,IAAI3C,MAAM,4HA3ChBiF,yBACIQ,EAAezI,EAAMxF,mEAmEtB/G,WACFoU,GAAW,IAEXxQ,OAAO5D,MAAMA,GAGZ,IAAIuP,MAAM,yFASPwC,YAAAA,gBACXhL,EACAmL,8BAEMnO,EAAMN,GAAG,SAAUsD,EAAMmL,2BAExBA,EAAEH,OAAS1R,EAAS6R,EAAEH,OAAX1R,CAAmB0G,GAAQlH,QAAQC,gDAM1C+U,YAAAA,eAAM9N,EAAuBmL,8BAClCnO,EAAMN,GAAG,QAASsD,EAAMmL,2BAEvBA,EAAE2C,MAAQxU,EAAS6R,EAAE2C,MAAXxU,CAAkB0G,GAAQlH,QAAQC,gDAMxCgV,YAAAA,eACX/N,EACAmL,EACA6C,8BAEMhR,EAAMN,GAAG,QAASsD,EAAMmL,2BAEvBA,EAAE4C,MAAQzU,EAAS6R,EAAE4C,MAAXzU,CAAkB0G,EAAMgO,GAAelV,QAAQC,gDAMrD0D,YAAAA,aAAIuD,EAAuBuB,OACtCwC,EAAIX,aAAapD,EAAKnH,KAAKuI,UAAWG,KAChC7E,GAAG,YAAasD,uCAMX6E,YAAAA,gBAAO7E,SACd8C,gBAAgB9C,EAAKiF,QAAQ7D,aAC3B1E,GAAG,iBAAkBsD,uCAMf2N,YAAAA,WACZxR,EACA6D,EACAmL,8BAEMnO,EAAMN,GAAGP,EAAM6D,EAAMmL,2BAEpBA,EAAEhP,GAAQ7C,EAAS6R,EAAEhP,GAAX7C,CAAkB0G,GAAQlH,QAAQC,2FC/R1CoV,GAoBXxT,SAAYyT,yBAhBgB,CAC1B,eACA,cACA,cACA,aACA,cACA,+BAKuC,IAAIvS,IAMtB,IAAjBuS,EAAM/T,SAOV+T,EAAMlS,iBAAQmS,KACPC,YAAYhS,IAAI+R,EAAKhN,UAAWgN,UAGlCzB,MAAM1Q,iBAAQlB,GACjBgC,EAAMhC,GAAMjE,EAAKwX,EAAYvT,GAAOjE,OAUhCwX,aAAAA,WAAYvT,8BACXgF,SACiBhF,EAAKuC,MAAM,UAAYyC,EAAKnH,KAAOmH,EAAKiF,QACxDoJ,EAAOtX,EAAKuX,YAAY9R,iBAI1B6R,GACFA,EAAKrT,IAASqT,EAAKrT,GAAMgF,KCnE5BwO,QAAQ/X,UAAUsJ,UACrByO,QAAQ/X,UAAUsJ,QACfyO,QAAgB/X,UAAUgY,mBAC3BD,QAAQ/X,UAAUiY,uBAKjBF,QAAQ/X,UAAUwT,UACrBuE,QAAQ/X,UAAUwT,QAAU,SAAiBjT,OACvC2K,EAAK5K,OAEN,IACG4K,EAAG5B,QAAQ/I,UACN2K,EAGTA,EAAMA,EAAGgN,eAAiBhN,EAAGuB,iBACf,OAAPvB,GAA+B,IAAhBA,EAAGiN,iBAEpB,OCZX,IAAaC,GAA0B,CACrCzN,eAAWrC,EACX0G,UAAM1G,EACNsC,eAAWtC,EACXkF,IAAK,CACHqC,UAAMvH,EACN8E,UAAM9E,EACN7B,UAAM6B,EACNwH,MAAO,KC+BEuI,GAAbnU,gDAQmCkU,eAIFnU,cAIP,IAAIA,EAAO,4BAIQ,cAU5BsC,WAYF+G,eACIkK,eACAxJ,eACA+C,WACJvD,yDAWN8K,aAAAA,aAAOC,EAAyB5R,OAC/B6R,EAAmBlY,KAAKmY,QAG1BD,EAAiBtP,QAAQqP,IAAW,OACjCnS,OAAOzB,gBAAgB4T,+BAKA,mBAAnBA,EAAOG,WAMXA,QAAQpY,KAAMqG,GACrB6R,EAAiB3U,KAAK0U,SANfnS,OAAOzB,gBAAgB4T,sCAyBzBlT,aAAAA,cACUiN,kBAWI,uCAVH,iCACN,mCACiB,qCACf,0DAEI,0CACG,iCACR5H,iCACD,sCACG,OAIbzG,EAAOK,UAAmB,IAAVQ,EAAiB,QAAU6T,QACtCvS,OAAOvB,KAAKvE,KAAKsY,gBAGflS,KAAKmS,GAAQpT,iBAAQuD,GAGtB0B,EAFS1B,OAAAA,GAGa6P,EAHb7P,WAMV8P,EAAsBzH,OACtBa,QAAUA,OACV6G,YAAcA,OACdC,eAAiBA,OAGjBC,EAAW3Y,KAAKgN,IAAItB,cACpB1L,KAAK2Y,QACF,IAAIlH,MAAM,6CAEbkH,EAASC,aAAa,YAAa,eAGnCC,UAEe7Y,KAAKiJ,iBAEpBiF,EAAQ7D,gBACL,IAAIoH,MAAM,kDAIbqH,MAAQ,IAAItI,EAAMiI,QAClBlO,QAAU,IAAI6I,EAAQsF,QACtB/E,YAAc,IAAIwC,EAAYxC,QAC9B0D,MAAQ,IAAID,GAAMC,GAGD,OAAlB0B,EAAwB,IACG,mBAAlBA,QACH,IAAItH,MAAM,mDAGblH,QAAQ7E,IAAI,gBAAiBqT,QAK/BrL,QAAQ3I,KAAKmJ,EAAQhB,IAAIJ,KAAMoB,EAAQ5D,gBAMvC0O,EAAehZ,KAAKgZ,EAAatY,KAAKV,WACtCiZ,EAAejZ,KAAKiZ,EAAavY,KAAKV,WACtCkZ,EAAiBlZ,KAAKkZ,EAAexY,KAAKV,WAC1CmZ,SAGAhB,QAAQhT,iBAAQ8S,UAAUA,EAAOlT,aAIhCqU,EAAYpZ,KAAKiJ,KAEvBmQ,EAAUC,QAAU,QACpBD,EAAUtX,KAAOsX,EAAUlL,aACtBjI,MAAMN,GAAG,QAASyT,QAGlBnF,OAAOmF,QAEPP,KAGAS,aAAAA,wBACAT,SACAU,SACA7L,QAAQzI,aACRgB,MAAMhB,aACNkT,QAAU,IAGjB5J,GAAItF,2BACKjJ,KAAKwZ,GAGdjL,GAAI/D,8BACKxK,KAAK2Y,GAMPc,aAAAA,eAAM3M,UAGJkC,SAAS0K,OAAO5M,IAclB6M,aAAAA,YACL7M,EACAuM,EACAhZ,OASI8T,oBAVe,SAIfnU,KAAK2T,YAAY0C,eACdoD,MAAM3M,aASXqH,EADc,aAAZkF,EAEArZ,KAAK0N,QAAQQ,SACblO,KAAKkN,IAAI0M,QAAQ5Z,KAAK0N,QAAQQ,QAAQhB,OAASlN,KAAKkN,IAAI0M,QAAQ9M,GAE3D9M,KAAKuK,QAAQiJ,IAAI,UAAW,KAAM,KAAM1G,KAGpC9M,KAAK2T,YAAY6C,YAKd,aAAZ6C,EAAwB,CAClBtZ,cAERsZ,EAAUrZ,KAAK0N,QAAQW,aAAatO,EAAM8H,YACrC6F,QAAQhI,IAAIoH,EAAM/M,EAAM0M,GAAI1M,EAAM8H,OAAO,aAEzC6F,QAAQhI,IAAIoH,EAAM,cAGrBzM,IACFA,EAAEwZ,kBACFxZ,EAAEyZ,kBAGG9Z,KAAKyO,KAAK3B,EAAMuM,EAASlF,KASrBF,aAAAA,gBAAOmF,aACZpZ,4BAAAO,EAAK0F,MAAMN,GAAG,cAAeyT,wDAe7B7Y,EAAK0F,MAAMN,GAAG,aAAcyT,2CAZ9B7Y,EAAKoT,YAAY4C,kCAEXjB,EAAa/U,EAAKoT,YAAYlO,IAAI2T,EAAW,SACzC,2BAGJ7Y,EAAKoT,YAAYgD,SAAS,YAAErB,OAAkB8D,kCAC7ClX,KACF4D,OAAO5D,MAAMA,uHAoBXuM,aAAAA,cACX3B,EACAuM,EACAlF,aAEAnU,sBAuBMiJ,EAAO6N,EAAK7N,4BAIZ6N,EAAK7Q,MAAMN,GAAG,OAAQsD,2CAGpBqM,EAAawB,EAAKnD,YAAYlO,IAAIwD,EAAM,SACpC,OACRkL,2BAGI2C,EAAKnD,YAAYkD,OAAO,MAC5B5N,OACAwF,aACA6G,EACA9K,QAASsM,EAAK6B,uBAGXE,gBACE3W,KAEF4D,OAAO5D,MAAMA,kDA7Cf+G,KAAKnH,KAAKoL,IAAMe,uBACnBnB,KACQI,IAAI7F,MAAMyF,MAEf7D,KAAKoQ,QAAUA,MAEd5K,EAAOqI,EAAKgC,MAAMxT,IAAIwH,GACxBgK,EAAKgC,MAAM9K,OAAOlB,EAAM,QAAU,UAAW2D,QAC7CqG,EAAKgC,MAAMvT,IACTuH,EACAgK,EAAKrG,QACH3D,EACAgK,EAAKlF,QACLkF,EAAKiD,eAAerZ,OAAW2Y,IAEjC,SACA5I,wBAGFqG,EAAKnD,YAAY8C,kCACbS,EAAezI,EAAMqI,EAAK7N,gGAkC7B8Q,aAAAA,wBAAeV,sEAEf1F,YAAY0C,WAAY,oBAGvB3F,EAAS1Q,KAAK8Y,MAAMlI,UAAU9D,eAC/BgM,MAAMjI,OAAO/D,KAIhB9M,KAAKwY,IACyD,IAA9DxY,KAAKwY,EAAoBa,EAAS3I,EAAQ5D,EAAMkN,KAMnC,UAAXtJ,QACG+I,MAAM3M,GAEN,KAMFmN,aAAAA,kBAASnN,cAGV9M,KAAK8Y,MAAMxT,IAAIwH,SAIdgM,MAAMvT,IACTuH,EACA9M,KAAKyQ,QACH3D,EACA9M,KAAK4R,QACL5R,KAAK+Z,eAAerZ,KAAKV,KAAM,UAC/Bka,eAAOhY,KACF4D,OAAO5D,MAAMA,KAEpB,aAOIiX,aAAAA,cAEsB,IAAxBnZ,KAAK0Y,0BACEyB,iBAAiB,YAAana,KAAKgZ,YACnCmB,iBAAiB,aAAcna,KAAKgZ,aAEtCmB,iBAAiB,QAASna,KAAKiZ,UACjCkB,iBAAiB,WAAYna,KAAKkZ,IAMnCK,aAAAA,cAEsB,IAAxBvZ,KAAK0Y,0BACE0B,oBAAoB,YAAapa,KAAKgZ,YACtCoB,oBAAoB,aAAcpa,KAAKgZ,aAEzCoB,oBAAoB,QAASpa,KAAKiZ,UACpCmB,oBAAoB,WAAYpa,KAAKkZ,IAStCF,aAAAA,WAAa3Y,cACbga,EAAOra,KAAKsa,EAAgBja,MAE7Bga,OAICvN,EAAO9M,KAAKgN,IAAIL,QAAQ0N,GAE1Bra,KAAKuK,QAAQ8F,SAASvD,IAKtB9M,KAAK8Y,MAAMxT,IAAIwH,SAIdgM,MAAMvT,IACTuH,EACA9M,KAAKyQ,QACH3D,EACA9M,KAAK4R,QACL5R,KAAK+Z,eAAerZ,KAAKV,KAAMqa,IAC/BH,eAAOhY,KACF4D,OAAO5D,MAAMA,KAEpB,WAWI+W,aAAAA,WAAa5Y,OAEbga,EAAOra,KAAKsa,EAAgBja,GAE7Bga,QAIAV,GAAG3Z,KAAKgN,IAAIL,QAAQ0N,GAAOA,EAAMha,IAShC6Y,aAAAA,WAAe7Y,QAChBsZ,GAAG3Z,KAAKkN,IAAI0M,QAAQ5Z,KAAKkN,IAAIP,WAAY,WAAYtM,IASpDia,aAAAA,WAAgBja,WAClBuK,EAAKvK,EAAEqS,OAEJ9H,IAAO5K,KAAKgN,IAAIL,QAAQ/B,IAC7BA,EAAMA,EAAmBuB,cAItBvB,IAAM5K,KAAKuK,QAAQkJ,UAAU7I,EAAIvK,EAAGL,KAAKgN,IAAIL,QAAQ/B,WAInDA,GAQDiO,aAAAA,iBACA/L,EAAO9M,KAAKkN,IAAI0M,QAAQ5Z,KAAKkN,IAAIP,WACjCuB,EAAU,CACd7D,UAAWrK,KAAKgN,IAAIlB,eACpB4C,KAAM1O,KAAKgN,IAAIzB,UACfjB,UAAWtK,KAAKgN,IAAIR,mBACfyB,uBACHnB,QACQI,IAAI7F,MAAMyF,UAIjB0M,EAAQ,SACXtL,EACApM,KAAMmM,iBAAKjO,KAAK8X,yBACP9P,QAGN/B,MAAMN,GAAG,QAAS3F,KAAKiJ,gDAIhClI,IAAMwZ,GAAO,IAAIxC"}